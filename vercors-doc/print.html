<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>VerCors Development Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Quick reference guide</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Adding a Language</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> New specifications</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> New modes</div></li></ol></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Techical Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup-workflow.html"><strong aria-hidden="true">2.1.</strong> Workflow</a></li><li class="chapter-item expanded "><a href="setup-language.html"><strong aria-hidden="true">2.2.</strong> Language</a></li><li class="chapter-item expanded "><a href="setup-build-system.html"><strong aria-hidden="true">2.3.</strong> Build System</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.1.</strong> ANTLR</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.2.</strong> Logback</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="col.html"><strong aria-hidden="true">3.</strong> Common Object Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="col-nodes.html"><strong aria-hidden="true">3.1.</strong> Nodes</a></li><li class="chapter-item expanded "><a href="col-ref.html"><strong aria-hidden="true">3.2.</strong> References</a></li><li class="chapter-item expanded "><a href="col-origin.html"><strong aria-hidden="true">3.3.</strong> Origins</a></li><li class="chapter-item expanded "><a href="col-check.html"><strong aria-hidden="true">3.4.</strong> Checking</a></li><li class="chapter-item expanded "><a href="col-coercion.html"><strong aria-hidden="true">3.5.</strong> Coercion</a></li><li class="chapter-item expanded "><a href="col-pp.html"><strong aria-hidden="true">3.6.</strong> Pretty-Printing</a></li><li class="chapter-item expanded "><a href="col-compare.html"><strong aria-hidden="true">3.7.</strong> Comparing</a></li><li class="chapter-item expanded "><a href="col-serialize.html"><strong aria-hidden="true">3.8.</strong> Serialization</a></li></ol></li><li class="chapter-item expanded "><a href="resolution.html"><strong aria-hidden="true">4.</strong> Resolution</a></li><li class="chapter-item expanded "><a href="rw.html"><strong aria-hidden="true">5.</strong> Rewriting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rw-outline.html"><strong aria-hidden="true">5.1.</strong> Outline</a></li><li class="chapter-item expanded "><a href="rw-dispatch.html"><strong aria-hidden="true">5.2.</strong> Dispatch</a></li><li class="chapter-item expanded "><a href="rw-generation.html"><strong aria-hidden="true">5.3.</strong> Generations</a></li><li class="chapter-item expanded "><a href="rw-succession.html"><strong aria-hidden="true">5.4.</strong> Succession</a></li><li class="chapter-item expanded "><a href="rw-blame.html"><strong aria-hidden="true">5.5.</strong> Blames</a></li><li class="chapter-item expanded "><a href="rw-nested.html"><strong aria-hidden="true">5.6.</strong> Nested Rewriters</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Substitution</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Backend and Errors</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Program Translation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Error Translation</div></li></ol></li><li class="chapter-item expanded "><a href="util.html"><strong aria-hidden="true">7.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="util-cache.html"><strong aria-hidden="true">7.1.</strong> Caching</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Profiling and Progress</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Importing</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VerCors Development Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Were you linked here, but not sure where to start? Maybe try a quick reference guide:</p>
<ul>
<li><a href="start-language.html">Adding a new input language to VerCors</a></li>
<li><a href="start-spec.html">Add a new type of specification to VerCors</a></li>
<li><a href="start-mode.html">Making VerCors do something other than verifying files</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>VerCors is a tool that tries to show programs to be correct. Correct may mean that the program finishes, that it does not crash, that it never throws an exception, or returns the correct result subject to some specification.</p>
<p>VerCors accepts programs in a variety of languages. For each language (also: <em>frontend</em>) the grammar is altered slightly, maintaining compatiblity with the source langauge grammar, so that we may add various annotations to the program. These annotations aid in verifying the program by specifying behaviour about it. This is crucial in automating the proof of the program.</p>
<p>As a tool VerCors works by passing the program through a large number of transformations. In general each transformation reduces the number of <em>features</em> in the program. You may think about features as different kinds of statements and operators. Various concerns are maintained in each element of the transformation. The most important guarded invariant is that of error transformations. As statement \(P\) is compiled into a different statement \(Q\), we have to remember how to translate errors about statement \(Q\) back into errors about statement \(P\).</p>
<p>An intermediate program is stored in VerCors as an <em>Abstract Syntax Tree</em> (short: AST). The internal language is also referred to as the <em>Common Object Language</em> (short: COL). Each part of the transformation is structured as a <em>Rewriter</em>, which visits each element in the AST. After visiting a node in the tree, the rewriter must specify what that node is replaced with. By default, the rewriter will recurse further into the tree, keeping the kind of node the same. For example, if we ask a default rewriter what \(p + q\) must be rewritten to, we will then ask what \(p\) and \(q\) will rewrite to. Supposing they rewrite to \(p'\) and \(q'\) respectively, the rewriter will by default restore the plus operator and return \(p' + q'\).</p>
<p>Around the transformation chain there are several steps. Unfortunately, syntax trees do not fall out of thin air, so we must first parse our text input into a tree. In VerCors, this is largely handled by by the ANTLR parser generator. We translate parse trees into COL trees as a part of the parsing stage, but there are no surprises there: as a matter of principle there is a corresponding COL node for each parse node. Next there is resolution: the process of associating each name in the tree with a referrable node. For example, variable names 'point' to the declaration of the variable. This stage usually presupposes that the file compiles at all.</p>
<p>After all the transformations we have a very simple program. On the other hand, proving it to be correct is no simple matter. We delegate this responsibility to Viper, a tool designed to automatically verify this dialect of program. Finally, a (hopefully empty) list of errors from Viper is translated into appropriate errors for the initial input to VerCors.</p>
<p>This completes the intended cycle of usage for VerCors: submitting a program to VerCors leads to a list of suggested improvements, which leads to editing the program, which leads to a new submission to VerCors. We have some qualitative wishes here: errors should be clear, specific and not a false negative. It should include context where appropriate, such as an example of how the error might occur. Ideally, VerCors is performant and can quickly establish whether or not there is an error.</p>
<p>The central goal is that we can encourage writers of critical software to prove their programs to be correct, so that their software is reliable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Were you linked here, but not sure where to start? Maybe try a quick reference guide:</p>
<ul>
<li><a href="start-language.html">Adding a new input language to VerCors</a></li>
<li><a href="start-spec.html">Add a new type of specification to VerCors</a></li>
<li><a href="start-mode.html">Making VerCors do something other than verifying files</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>VerCors is a tool that tries to show programs to be correct. Correct may mean that the program finishes, that it does not crash, that it never throws an exception, or returns the correct result subject to some specification.</p>
<p>VerCors accepts programs in a variety of languages. For each language (also: <em>frontend</em>) the grammar is altered slightly, maintaining compatiblity with the source langauge grammar, so that we may add various annotations to the program. These annotations aid in verifying the program by specifying behaviour about it. This is crucial in automating the proof of the program.</p>
<p>As a tool VerCors works by passing the program through a large number of transformations. In general each transformation reduces the number of <em>features</em> in the program. You may think about features as different kinds of statements and operators. Various concerns are maintained in each element of the transformation. The most important guarded invariant is that of error transformations. As statement \(P\) is compiled into a different statement \(Q\), we have to remember how to translate errors about statement \(Q\) back into errors about statement \(P\).</p>
<p>An intermediate program is stored in VerCors as an <em>Abstract Syntax Tree</em> (short: AST). The internal language is also referred to as the <em>Common Object Language</em> (short: COL). Each part of the transformation is structured as a <em>Rewriter</em>, which visits each element in the AST. After visiting a node in the tree, the rewriter must specify what that node is replaced with. By default, the rewriter will recurse further into the tree, keeping the kind of node the same. For example, if we ask a default rewriter what \(p + q\) must be rewritten to, we will then ask what \(p\) and \(q\) will rewrite to. Supposing they rewrite to \(p'\) and \(q'\) respectively, the rewriter will by default restore the plus operator and return \(p' + q'\).</p>
<p>Around the transformation chain there are several steps. Unfortunately, syntax trees do not fall out of thin air, so we must first parse our text input into a tree. In VerCors, this is largely handled by by the ANTLR parser generator. We translate parse trees into COL trees as a part of the parsing stage, but there are no surprises there: as a matter of principle there is a corresponding COL node for each parse node. Next there is resolution: the process of associating each name in the tree with a referrable node. For example, variable names 'point' to the declaration of the variable. This stage usually presupposes that the file compiles at all.</p>
<p>After all the transformations we have a very simple program. On the other hand, proving it to be correct is no simple matter. We delegate this responsibility to Viper, a tool designed to automatically verify this dialect of program. Finally, a (hopefully empty) list of errors from Viper is translated into appropriate errors for the initial input to VerCors.</p>
<p>This completes the intended cycle of usage for VerCors: submitting a program to VerCors leads to a list of suggested improvements, which leads to editing the program, which leads to a new submission to VerCors. We have some qualitative wishes here: errors should be clear, specific and not a false negative. It should include context where appropriate, such as an example of how the error might occur. Ideally, VerCors is performant and can quickly establish whether or not there is an error.</p>
<p>The central goal is that we can encourage writers of critical software to prove their programs to be correct, so that their software is reliable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="techical-setup"><a class="header" href="#techical-setup">Techical Setup</a></h1>
<p>This chapter describes some of the technical setup around vercors, like version control, programming language choice, and libraries. It can be referred back to when evaluating changes to the setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow"><a class="header" href="#workflow">Workflow</a></h1>
<p>Since VerCors is made by Real Humansâ„¢ we agreed on some administrative conventions to stick by:</p>
<ul>
<li>If you have a bug or clearly delineated feature request, it should exist as an issue on our tracker on GitHub: <a href="https://github.com/utwente-fmt/vercors/issues">https://github.com/utwente-fmt/vercors/issues</a>. The goal is to have zero issues: that should be achievable, since it should be clear what to do from the issue.</li>
<li>If you have a more vague feature request, or a question, or you're not sure if something is a bug, it should be a discussion: <a href="https://github.com/utwente-fmt/vercors/discussions">https://github.com/utwente-fmt/vercors/discussions</a>.</li>
<li>If you're working on VerCors code longer term, we prefer that you do so in a <em>branch</em> in the main repository, rather than working in a fork. Please ask for push access when starting out.</li>
<li>If you're working on a single issue, please assign yourself the issue.</li>
<li>We use feature branches and pull requests, so once you're done please file a pull request. Contiuous integration will run all examples on your changes automatically, so it's wise to check if it succeeded.</li>
<li>We do not have a linting policy at this time. We ask that try to follow local conventions of files you're editing and do not reformat whole files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>VerCors is a JVM project, and the current main language we use is Scala. We do accept contributions in both Scala and Java, but we highly encourage you to learn some Scala before contributing.</p>
<p>Since the main backend of VerCors is currently Viper, we enjoy the benefit of calling into it directly and being able to debug it directly, since VerCors is also a JVM application.</p>
<p>We primarily develop VerCors in Scala for several reasons:</p>
<ul>
<li>Scala has great support for functional programming paradigms. VerCors primarily deals with immutable data-structures and pushes out effects, like logging verification failures and writing out files.</li>
<li>Scala supports pattern matching, which is very suitable for analysing ASTs.</li>
<li>Scala supports metaprogramming, which is very handy for generating functionality that recurses into the ASTs: rewriters, comparators, etc.</li>
<li>Other nice to haves: good collection api (sequences, sets), optional structural equality, sealed types.</li>
</ul>
<p>On the surface it seems Kotlin has significant feature overlap with Scala, but some of the above points are not available and are important. We may revisit that stance in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-system"><a class="header" href="#build-system">Build System</a></h1>
<p>The default build system for Scala, and hybrid Scala/Java project, is SBT. However, our current build system is <a href="https://mill-build.com/">mill</a>. For a general overview of why we don't use SBT anymore, see <a href="http://www.lihaoyi.com/post/SowhatswrongwithSBT.html">here</a>.</p>
<p>For us specifically we considered these things:</p>
<ul>
<li>For meta-build alterations in ColHelper, it was annoying to remember that you need to reload.</li>
<li>You needed to alter the IntelliJ settings immediately, otherwise the project does not build by default.</li>
<li>The run script broke for almost every user, because we use a custom classpath caching solution, because sbt "run example.pvl" starts up way too slow (~7 seconds when vercors is already entirely compiled).</li>
<li>Most people had encountered a situation where the project just breaks, and you need to re-import everything.</li>
<li>Anything custom was hard to implement, because we didn't understand enough about how sbt works.</li>
</ul>
<p>Mill on the other hand does not have these drawbacks:</p>
<ul>
<li>It is almost just scala.</li>
<li>Tasks are a straightforward and easy abstraction:
<ul>
<li>Custom stuff is easy to implement, even when interacting with mill internals.</li>
<li>Caching is essentially free due to the data model.</li>
<li>Tooling around mill is easy, because the hierarchy in the build definition corresponds to the hierarchy in <code>out</code>.</li>
<li>You can chain tasks entirely as you like and mill is fine with it: e.g. <code>col.generatedSources</code> depends on <code>colMeta.meta.runClasspath</code>.</li>
</ul>
</li>
<li>Mill boots with the vercors build in under one second, e.g. <code>time ./mill -j 0 vercors.runScript</code> -&gt; <code>real 0m0,753s</code>
<ul>
<li>This means we can finally get rid of our own classpath abstraction: we can be sure vercors runs normally every time.</li>
</ul>
</li>
<li>Mill seems to work well with IntelliJ via the BSP integration, which does not need any altered settings in IntelliJ.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-object-language"><a class="header" href="#common-object-language">Common Object Language</a></h1>
<p>The Common Object Language (short: COL) is the intermediate representation of VerCors. The main component of VerCors is to apply a sequence of transformations (rewriters) to the COL tree until it is suitable to submit to a backend. This chapter describes concepts around the structure of COL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>COL programs are stored in a tree-like immutable data structure. All nodes are defined in <code>src/col/vct/col/ast/Node.scala</code>. Other than some primitive types and collection types like <code>Int</code>, <code>String</code>, <code>Seq[_]</code> and tuples <code>(_, _)</code>, all types in the tree are descendants of <code>Node</code>.</p>
<p>Nodes are split into two kinds:</p>
<ul>
<li><strong>Descendants of <code>NodeFamily</code></strong>. These are regular nodes, like expressions and statements.
<ul>
<li>They have structural equality, meaning comparing them constitutes comparing their fields.</li>
<li>It makes sense to say that each family of nodes should rewrite to itself: one <code>Statement</code> should always be rewritten to another <code>Statement</code>.</li>
</ul>
</li>
<li><strong>Descendants of <code>Declaration</code></strong>. These are nodes to which we can refer.
<ul>
<li>They have reference equality, which means a <code>new Variable(TInt) != new Variable(TInt)</code>.</li>
<li>It make sense to ask in which scope the declaration can be referred to. For example, a reference to an argument makes no sense outside the method it is declared in.</li>
<li>We should be able to rewrite a declaration to zero, one or more successors of itself.</li>
</ul>
</li>
</ul>
<p>We will not exhaustively describe all kinds of node here, but we highlight the ones that have special Properties.</p>
<h2 id="expr"><a class="header" href="#expr">Expr</a></h2>
<p>All expressions have a type:</p>
<pre><code class="language-scala">trait ExprImpl[G] { this: Expr[G] =&gt;
	def t: Type[G]
}
</code></pre>
<p>You may presume that the node is <code>check</code>ed before its type is queried, and may crash otherwise. The type of expressions is closely related to coercion.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>The relations between types must be defined in <code>Types.leastCommonSuperType</code> and <code>CoercionUtils.getCoercion</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>The normal way to create references to a declaration in a program is by naming it. This creates a few obligations, for example:</p>
<ul>
<li>Declarations must have a consistent and unique name with regards to its scope</li>
<li>References to a declaration must name an existing declaration</li>
<li>Renaming declaration must consider all its references
(Otherwise, we may silently refer to the wrong declaration)</li>
<li>Moving declarations or references across scopes must consider what declaration we are pointing to
(Otherwise, we may silently refer to the wrong declaration)</li>
<li>Importing internal definitions and generating side conditions must generate fresh unique names
(Otherwise, we may silently refer to the wrong declaration)</li>
</ul>
<p>We had this approach in earlier versions of VerCors, leading to declarations with a lot of underscores, and <code>VERCORS</code>/<code>SYSTEM</code>/<code>INTERNAL</code> prefixes. Even still this would probably be pretty manageable as long as the number of rewriters is not too big. As of writing we have 67 different rewriting steps, so this is no longer the case.</p>
<h2 id="no-names"><a class="header" href="#no-names">No names!</a></h2>
<p>We have instead elected to get rid of names entirely, replacing them with explicit references instead. This is a lie, because the initial input to VerCors of course <em>does</em> contain names, but it is a convenient lie: in all other passes the names are not relevant to rewriters. For debug output the preferred name for declarations is stored nevertheless in the <code>preferredName</code> of the origin of the declaration.</p>
<h2 id="tying-the-knot"><a class="header" href="#tying-the-knot">Tying the knot</a></h2>
<p>For simple declaration types like variables, we need to do nothing special to rewrite them. We can think of the following order to rewrite them:</p>
<ul>
<li>Rewrite all the variables of a <code>Scope</code></li>
<li>Rewrite the body of the <code>Scope</code>, which may or may not contain references to the variables.</li>
</ul>
<p>We can then account which <code>Pre</code>-variable is rewritten to which <code>Post</code>-variable, and substitute references accordingly. Note that the variables of the <code>Scope</code> may themselves contain references to variables (e.g. type variables), but we can argue that by the structure of the scopes they have already been rewritten.</p>
<p>This convenient structure manifestly does not work for e.g. method invocations. Consider this simple program:</p>
<pre><code>void p() {
	q();
}

void q() {
	p();
}
</code></pre>
<p>There is no way to order the rewrites correctly here:</p>
<ol>
<li>We cannot name the succesor of <code>p</code> before rewriting <code>p</code></li>
<li>We cannot rewrite the body of <code>p</code> before knowing the successor of <code>q</code></li>
<li>We cannot name the succesor of <code>q</code> before rewriting <code>q</code></li>
<li>We cannot rewrite the body of <code>q</code> before knowing the successor of <code>p</code></li>
<li><code>goto 1</code></li>
</ol>
<p>The way we resolve this by making references lazy in general. We can still refer directly to declaration that we know of in context, such as temporary variables, by wrapping them in <code>DirectRef</code>. If not, we supply the computation that will resolve the reference to <code>LazyRef</code>. Importantly, this computation need not be valid immediately, it must be correct only after the <code>Rewriter</code>.</p>
<p>By default, we store one-to-one succesors in a map. References then by default construct a <code>LazyRef</code> that looks up the successor in this map. The actual mechanics of this are explained further in <a href="resolution.html">Resolution</a> and <a href="rewriting-succession.html">Succession</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="origins"><a class="header" href="#origins">Origins</a></h1>
<p>The origin is a mandatory field in every node, and is the facility by which we store any and all metadata about the node. It arranges the preferred naming scheme of nodes that should have a name, it describes the context in which the node was created, and can remember what text range(s) in the input participated in making the node.</p>
<p>As it is metadata that is nominally not semantically relevant, it does not participate in the structural equality of nodes.</p>
<h1 id="naming"><a class="header" href="#naming">Naming</a></h1>
<p>The name of a node is not relevant to rewriting logic, so it is included in the metadata. For simple source input, the preferred name is just the same as it is in the source. For generated nodes we can use <code>PreferredName</code> and <code>NamePrefix</code> to indicate the preferred name, or its shorthand <code>Origin.where(name = ..., prefix = ...)</code>. We emphasize once more that the name has no semantic relevance: VerCors would be equally sound if all preferred names are <code>x</code>.</p>
<p>The preferred name is currently used in two places:</p>
<ul>
<li><code>vct.col.print.Namer</code> for debug output and some source transformation outputs (e.g. VeyMont);</li>
<li><code>viper.api.transform.ColToSilver</code> for serialization into the Viper language.</li>
</ul>
<h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>For debugging purposes we can add context to an origin. This is typically not necessary for reporting verification failures, as they are reported very close to the input origin. Nevertheless it is useful to know why a node exists, so we mostly add ad-hoc instances of <code>LabelContext</code>, or its shorthand <code>Origin.where(context = ...)</code>.</p>
<h1 id="source-context"><a class="header" href="#source-context">Source Context</a></h1>
<p>Most origins contain at least one pair of <code>ReadableOrigin</code> and <code>PositionRange</code>. Often it is tempting to "just ask" what file position a node comes from, but it is not very often so straightforward to explain away the reason a node exists as such. Nevertheless it is useful to know what source code primarily contributed to the node.</p>
<p><code>Origin</code> extends <code>HasContext</code>, which defines <code>messageInContext</code> to render a message in the context it describes. This will usually contain the file name, as well as the fragment in the file that the origin refers to. There is also <code>Origin.shortPosition</code>, which will attempt to locate an arbitrary file position in the <code>Origin</code> - this is generally not advisable to use outside debugging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking"><a class="header" href="#checking">Checking</a></h1>
<p>In general we attempt to design the AST in such a way that it is not possible to represent invalid situations. When that is not possible, we implement structural checks on the AST when it is convenient.</p>
<h1 id="the-ambiguous-pattern"><a class="header" href="#the-ambiguous-pattern">The <code>Ambiguous</code> pattern</a></h1>
<p>To avoid duplicating code we implement a rigid structure first in a lot of cases, that does not yet connect to the frontends. An example of this is <code>Location</code>, which has rigid alternatives per type of heap location. Since <code>Perm(x.f, _)</code> simply contains an expression <code>x.f</code> rather than something that is immediately identifiable as a location, we punch a hole in <code>Location</code> named <code>AmbiguousLocation</code> that can contain that expression for so long as it is not yet resolved. We then implement a rewriter that scans for the allowed forms of expression in <code>AmbiguousLocation</code> and translates them to a proper location. If the form is not proper, we can simply throw a <code>UserError</code> in the rewriter.</p>
<p>The alternative is that we implement <code>check</code> for <code>AmbiguousLocation</code> and ensure that it contains a correct location. It is not that clear when a location is valid. For example, a <code>JavaDeref</code> can be resolved to a built-in like <code>seqn.size</code>. That does not resolve to a correct location, but it is more convenient to wait until the <code>JavaDeref</code> becomes a <code>Size</code>, rather than needing to be aware of every possible resolution of <code>JavaDeref</code> in <code>AmbiguousLocation</code>.</p>
<h1 id="type-checks"><a class="header" href="#type-checks">Type checks</a></h1>
<p>One dimension along which we cannot escape checking is that of type constraints. Every node that <strong>contains</strong> an expression defines whether it imposes a type constraint on it in <code>CoercingRewriter</code>. This coercion is computed in the implementation of <code>check</code> for every node.</p>
<h1 id="structural-checks"><a class="header" href="#structural-checks">Structural checks</a></h1>
<p>As said before the amount of structural checks implemented in VerCors currently is very limited. Nevertheless we are still missing some important ones at time of writing, so we should look into this more.</p>
<p>The ones that do exist are implemented by extending <code>CheckError</code>, and then overriding <code>check</code> in the Impl-trait of the node you want to implement a check for. Note that it is typically wanted behaviour that the <code>super</code>-implementation of <code>check</code> is included in the result.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coercion"><a class="header" href="#coercion">Coercion</a></h1>
<p>Various nodes contain expressions, such as other expressions (e.g. <code>Plus</code> contains its two arguments) and non-expressions (e.g. <code>Branch</code> contains the conditions for its branches). Each expression position in the tree may induce a typing constraint on the expression in it. For example, the conditions in <code>Branch</code> have to be booleans:</p>
<pre><code class="language-scala">case Branch(branches) =&gt; 
	Branch(branches.map { case (cond, effect) =&gt; (bool(cond), effect) })
</code></pre>
<p>and the arguments of <code>Plus</code> may be integers or rationals:</p>
<pre><code class="language-scala">case Plus(left, right) =&gt;
	firstOk(e, s"Expected both operands to be numeric, but got ${left.t} and ${right.t}.",
		Plus(int(left), int(right)),
		Plus(rat(left), rat(right)),
	)
</code></pre>
<p>Here we coerce each <code>cond : Expr[G]</code> into a boolean, and do nothing with <code>effect</code>. For <code>Plus</code> we pick the first of two transformations that succeeds: either both <code>left</code> and <code>right</code> can be coerced with <code>int</code>, or both can be coerced with <code>rat</code>.</p>
<p>Coercions serve two purposes: they check that the AST is well-typed, and can be used in <code>Rewriter</code>s to enact transformations on the AST.</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type checking</a></h2>
<p>The coercions in <code>CoercingRewriter</code> are run for every node during a <code>check</code> in the implementation of <code>DeclarationImpl</code> and <code>NodeFamilyImpl</code> (which together span all nodes). They use a special descendant of <code>CoercingRewriter</code> called <code>NopCoercingRewriter</code> that applies no transformtions along coercions.</p>
<p>All nodes that contain expressions should have their coercions defined in <code>CoercingRewriter</code>. If the expression should be in a simple type (class), you can use <code>coerce(expression : Expr[Pre], type : Type[Pre])</code>. Shorthands for several common types are defined, such as <code>rat</code>, <code>bool</code> and <code>int</code>.</p>
<p>If your node can be interpreted in multiple ways, determined by the type of its arguments, you can use the <code>firstOk</code> helper to select the first set of coercions that suceed on the arguments. Only if all alternatives fail an error is raised.</p>
<h2 id="transformations"><a class="header" href="#transformations">Transformations</a></h2>
<p>It is occasionally useful to implement transformation along the description of a coercion. Coercions are described by the node family <code>Coercion</code>. For example, coercing a <code>seq&lt;int&gt;</code> into a <code>seq&lt;rational&gt;</code> is described by <code>CoerceMapSeq(CoerceIntRat(), TInt(), TRational())</code>. Rewriters that extend <code>CoercingRewriter</code> have access to this coercion object by overriding <code>applyCoercion</code>.</p>
<p>One example of this behaviour is in the overloaded interpretation of <code>null</code>. In VerCors the array types are entirely separate from the class types. Thus, <code>null</code> can be coerced into either an array or a class type. In the rewriter that encodes arrays, <code>ImportArray</code>, we filter for usages of <code>null</code> for arrays by translating a <code>CoerceNullArray</code> coercion to the appropriate value for a null array.</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>Note that very nearly all defined/permissible coercions are promoting coercions. That is, they only admit coercions when a value definitely fits into the target type of the coercion. This is defined programatically by defining <code>isPromoting</code> in <code>CoercionImpl</code>. Currently the only exception is rationals into <code>zfrac</code> into <code>frac</code>. We have not investigated yet whether it is a good idea to define more implicit coercions to represent situations like demoting a <code>uint64</code> into a <code>uint32</code> - perhaps they are better suited as explicit non-<code>ApplyCoercion</code> nodes at an early point. Failures in coercion are reported to the blame in <code>Program</code>, mostly because we have no other good place to put it.</p>
<p>The other safety concern related to promoting coercions is that sets only map over promoting coercions due to the fact that the default coercion is defined as \(x \in \textsf{input} \leftrightarrow \textsf{coerce}(x) \in \textsf{output}\). Alternative encodings we investigated are cumbersome because they add additional necessary proof steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretty-printing"><a class="header" href="#pretty-printing">Pretty-Printing</a></h1>
<p>The pretty printer of VerCors is derived from "A prettier printer" by Philip Wadler, accessible <a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">here</a>. Typesetting a COL AST is done in three stages: it is first translated into a document tree, then a list of elements, then text.</p>
<h1 id="col"><a class="header" href="#col">COL</a></h1>
<p>Each node implements <code>layout</code>, which is externally accessible via <code>show</code>. The only purpose of <code>show</code> is to wrap the document tree with <code>NodeDoc</code>, so that we may later recall what document tree corresponds to what COL tree. If you forget to implement <code>layout</code> a debugging representation of the node is printed that does not look entirely terrible.</p>
<p><code>Expr</code> is a bit more special: it demands an implementation of <code>def precedence: Int</code> for each expression. You can use <code>bind</code>, <code>assoc</code>, <code>nassoc</code>, <code>lassoc</code> and <code>rassoc</code> as conveniences to see whether sub-expressions require parentheses:</p>
<ul>
<li><code>bind</code> adds parentheses if the precedence of the subexpression is lower than the specified precedence</li>
<li><code>assoc</code> adds parentheses if the precedence of the subexpression is strictly lower than our precedence (i.e. we "associate" with the subexpression)</li>
<li><code>nassoc</code> adds parentheses if the precedence of the subexpression is less or equal than our precedence (i.e. we do not "associate" with the subexpression)</li>
<li><code>lassoc</code> is the correct implementation for a left-associative binary operator (e.g. <code>+</code>, <code>*</code>)</li>
<li><code>rassoc</code> is the correct implementation for a right-associative binary operator (e.g. <code>::</code>, <code>==&gt;</code>)</li>
</ul>
<h1 id="document-tree"><a class="header" href="#document-tree">Document tree</a></h1>
<p>The elements of a document tree are as follows:</p>
<ul>
<li><code>Empty</code>, which renders as nothing</li>
<li><code>Text(String)</code>, which simply represents a piece of text. Must not contain newlines.</li>
<li><code>Cons(Doc, Doc)</code> (or <code>Doc &lt;&gt; Doc</code>), which represents the unspaced concatenation of two trees.</li>
<li><code>Nest(Doc)</code>, which indicates the tree should be nested (i.e. indented)</li>
<li><code>Group(Doc)</code>, which indicates that newlines should preferrably be removed from the tree.</li>
<li><code>Line</code> and <code>NonWsLine</code>, which are both newlines. If collapsed in a <code>Group</code>, only <code>Line</code> is replaced with one space.</li>
<li><code>NodeDoc(Node[_], Doc)</code>, which has no effect on typesetting, but indicates this document tree corresponds to this node.</li>
</ul>
<p>The deviations from Wadler's algorithm are:</p>
<ul>
<li>We have no <code>&lt;|&gt;</code> to indicate alternatives. Instead our very opinionated <code>Group</code> has in effect two alternatives: we prefer for it to be printed on one line, but it may keep the <code>Line</code>s and <code>NonWsLine</code>s if necessary to reduce its horizontal occupancy. When <code>Group</code> is nested we first peel off the outer <code>Group</code>, keeping the inner <code>Group</code> if possible.</li>
<li>The <code>flatten</code> of <code>NonWsLine</code> is <code>Empty</code> instead of <code>Text(" ")</code></li>
<li><code>NodeDoc</code> is there for post-processing</li>
</ul>
<p>Otherwise the typesetting algorithm is a straightforward transliteration of the paper.</p>
<p><code>Doc</code> has several convenient operators to make trees:</p>
<ul>
<li>On the right hand side of operators, you can write anything that implements <code>Show</code>, such as <code>Node[_]</code></li>
<li><code>x &lt;&gt; y</code> is <code>Cons(x, y)</code></li>
<li><code>x &lt;+&gt; y</code> is <code>x &lt;&gt; " " &lt;&gt; y</code></li>
<li><code>x &lt;/&gt; y</code> is <code>x &lt;&gt; NonWsLine &lt;&gt; y</code></li>
<li><code>x &lt;+/&gt; y</code> is <code>x &lt;&gt; Line &lt;&gt; y</code></li>
<li><code>x &lt;&gt;&gt; y</code> is <code>x &lt;&gt; Nest(Line &lt;&gt; y)</code></li>
<li><code>Doc.fold</code> applies a function on pairs of <code>Doc</code> until there is only one <code>Doc</code>. If the sequence of <code>Doc</code>s is empty, the result is <code>Empty</code>.</li>
<li><code>Doc.spread</code>, <code>Doc.lspread</code> and <code>Doc.rspread</code> place spaces between <code>Doc</code>s. <code>r</code> has an extra space on the right, <code>l</code> has an extra space on the left.</li>
<li><code>Doc.stack</code> places newlines between <code>Doc</code>s that reduce to a space in a <code>Group</code>.</li>
<li><code>Doc.arg</code> indents a <code>Doc</code> on a new line, then appends another newline. Both newlines reduce to nothing in a <code>Group</code>. Appropriate for an argument to a function or control structure like <code>while</code>, when wrapped in a <code>Group</code>.</li>
<li><code>Doc.args</code> combines comma-separated arguments with newlines that reduce to a space.</li>
<li><code>Doc.spec</code> and <code>Doc.inlineSpec</code> surround the <code>Doc</code> with <code>/*@ @*/</code> if necessary. Note: the context only indicates to the tree argument that we are now in a spec if the argument to <code>Doc.spec</code> is not yet a <code>Doc</code>, but something yet to be showed. This can be delayed with <code>Show.lazily</code> if necessary.</li>
</ul>
<h1 id="elements"><a class="header" href="#elements">Elements</a></h1>
<p>After typesetting the document we are left with a list of elements, which are one of two variants:</p>
<ul>
<li><code>ELine(indent: Int)</code>, which renders a new line with a given amount of indentation. The context contains an indentation string, that is repeated <code>indent</code> amount of times</li>
<li><code>EText(text: String)</code>, which is rendered as its constitutent text.</li>
</ul>
<p>Additionally, we again remember what corresponds to which node, for post-processing:</p>
<ul>
<li><code>EStart(Node[_])</code> indicates the start of a region that represents that node.</li>
<li><code>EEnd(Node[_])</code> indicates the end of that region.</li>
</ul>
<p>The metadata is used in <code>Doc.highlight</code>, which can point to a node in a rendered tree.</p>
<p>Any node that implements <code>Show</code> has convenience functions <code>write(Appendable)</code> and <code>toStringWithContext(Ctx)</code> to convert the <code>Show</code> to text.</p>
<h1 id="context-1"><a class="header" href="#context-1">Context</a></h1>
<p>The class <code>vct.col.print.Ctx</code> is available when rendering nodes and can be updated when the parent context is relevant (such as being inside a specification). Otherwise it contains information like declaration names, the horizontal width, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparing"><a class="header" href="#comparing">Comparing</a></h1>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>All nodes already implement <code>==</code>, which corresponds to the property that the nodes are semantically equivalent. This means that the following properties of nodes are considered when checking them for equality:</p>
<ul>
<li>Descendants of <code>NodeFamily</code> are deemed equal by structural equality: they must be of the same type, and have the same fields recursively.</li>
<li>Descendants of <code>Declaration</code> are deemed equal by referential equality: two separate instances of structurally equal <code>Declaration</code>s are <em>not</em> equal.</li>
<li>The <code>blame</code> of nodes is <em>not</em> considered in equality: this is an unfortunate design mistake. Blames should be redesigned so that they are a structural component of the AST.</li>
<li>The origin of nodes is not considered in equality: this is correct, because the origin only contains metadata not relevant for the boolean verification result of the node.</li>
</ul>
<p>If this notion of equality does not fit, you can instead use <code>compare</code>.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Each node implements <code>compare</code> through code generation. Its only argument is the node to compare to, and it returns a lazy list of <code>CompareResult</code>. The idea is that <code>compare</code> recurses into the left and right argument simultaneously, reporting any differences along the way. The three alternatives for <code>CompareResult</code> are:</p>
<ul>
<li><code>StructuralDifference</code>: in this subtree the kinds of node are different, or they have a different structure at that level. For example: a node that contains a <code>Seq</code> has a differing number of arguments.</li>
<li><code>MatchingReference</code>: so far the tree is structurally equal, and we have recursed to a point that left and right are a reference to a declaration. The references may or may not be equal.</li>
<li><code>MatchingDeclaration</code>: these declarations are structurally equivalent, but they may or may not be reference-equal.</li>
</ul>
<p>From here several useful abstractions are implemented:</p>
<ul>
<li><code>Compare.compare</code>: the same as <code>compare</code> above, but attempt to reconcile structural differences by bringing left and right into a specified normal form. This is useful to compare nodes e.g. under equivalence of associativity of <code>**</code>.</li>
<li><code>Compare.getIsomorphism</code>: attempts to match up <code>MatchingReference</code> and <code>MatchingDeclaration</code> that point to the same declarations. If this succeeds, we say that left and right are isomorphic by substituting left declaration for right declarations. In that case the result is <code>Right</code>: a map of left-declaration to right-declaration. If not, a list of differences is returned: either structural differences or declarations that cannot be reconciled.</li>
<li><code>ApplyTermRewriter</code>: uses <code>compare</code> to implement rewriting rules, by explicitly accepting a <code>StructuralDifference</code> in the case that the left term is a <code>Local</code> used in the rule pattern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization"><a class="header" href="#serialization">Serialization</a></h1>
<p>A lightly used feature of COL is serialization and deserialization: the ability to store a COL tree as an array of bytes, and the ability to translate the bytes back into a COL tree.</p>
<h2 id="serialization-on-the-vercors-side"><a class="header" href="#serialization-on-the-vercors-side">Serialization on the VerCors side</a></h2>
<p>Each node defines two serialization methods:</p>
<pre><code>def serialize(decls: Map[Declaration[G], Long]): vct.col.ast.serialize.&lt;Node&gt;

def serializeFamily(decls: Map[Declaration[G], Long]): vct.col.ast.serialize.&lt;NodeFamily&gt;
</code></pre>
<p>The <code>decls</code> parameter is used to store the representation of references in the AST. There is also a utility method <code>vct.col.ast.Serialize.serialize</code> that computes a standard assignment of declaration to <code>Long</code> for a <code>Program</code>.</p>
<p>For deserialization objects are generated for each node in <code>vct.col.ast.ops.deserialize</code>, but again the <code>vct.col.ast.Deserialize.deserialize</code> method is there for conveniently deserializing <code>Program</code> nodes.</p>
<h3 id="usage-of-serialization"><a class="header" href="#usage-of-serialization">Usage of serialization</a></h3>
<p>Currently the only usage of serialization internal to VerCors is to cache library files and user inputs. Library files are cached by default, which saves us from having to continually parse them on each run of VerCors. User inputs are currently only cached when a development flag is enabled.</p>
<h2 id="serialization-outside-vercors"><a class="header" href="#serialization-outside-vercors">Serialization outside VerCors</a></h2>
<p>(De)serialization takes an extra step between COL trees and bytes through Protobuf. For those familiar with protobuf, we break with two important standards that are common for protobuf definitions:</p>
<ul>
<li>We do not promise backward or forward compatiblility: we are still in a stage where we extensively experiment with node representation, so we are careful that communication of serialized programs only occurs between identical versions of the serialization format. We may want to have some form of backward compatibility in the future.</li>
<li>The protobuf definition is not the source of truth. Instead we derive a protobuf definition from <code>Node.scala</code>. It may be sensible to explicitly maintain a version of the protobuf definition in tandem with switching to a notion of backwards compatible nodes.</li>
</ul>
<p>On to the good parts: for any VerCors version you can find its protobuf definitions at <code>out/vercors/col/helpers/global/generate.dest/vct/col/ast/col.proto</code>. You can use this file to generate bindings for all common programming languages. This effectively makes it so that any programming language can be used to generate an input to VerCors, e.g. by extending a compiler in whatever language that is written.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolution"><a class="header" href="#resolution">Resolution</a></h1>
<p>Resolution is the process of assigning a meaning to a text name. Resolution occurs in two stages:</p>
<ul>
<li><code>vct.col.resolve.ResolveTypes</code>: Resolves the meaning of types, and loads any library types that are mentioned but not in the input. Declaration with a type can be important in resoving other references, such as field dereferences.</li>
<li><code>vct.col.resolve.ResolveReferences</code>: Resolves everything else.</li>
</ul>
<p>Both resolution stages have the same structure. At each node we receive a context that decides how we resolve that particular node. Before resolving any node, we fist resolve all of its children. This is because the type and well-formdness of children is more often relevant to the parent, than the well-formdness of the parent is to the children. The context is expanded upon by a node before passing it to its children. The recipe is thus as such:</p>
<ol>
<li><code>enterContext</code> decides how to expand the context from a node</li>
<li><code>resolve</code> recureses into the node's children with the updated context</li>
<li><code>resolveOne</code> is called for the node, which may assume the children are well-formed.</li>
</ol>
<p><code>ResolveTypes</code> is followed by its companion rewriter <code>LangTypesToCol</code>, which sets the resolved references in mutable state in stone. Dually the <code>ResolveReferences</code> resolver is followed by <code>LangSpecificToCol</code>.</p>
<h2 id="from-parse-tree-to-col-tree"><a class="header" href="#from-parse-tree-to-col-tree">From parse tree to COL tree</a></h2>
<p>VerCors has two ways of representing a text name:</p>
<ul>
<li>A node contains a <code>Ref</code> that is of type <code>UnresolvedRef</code>. This is appropriate for places where the name is exactly one label (as opposed to a fully qualified name like <code>java.lang.String</code>), and will clearly resolve to a category of declaration. This is unfortunately quite often not the case.</li>
<li>A node remembers the text name temporarily, and contains mutable state to receive the result of resolution. An example of this is <code>JavaLocal</code>.</li>
</ul>
<p>This is an area of VerCors that should be refactored: there should be one clear way to represent an unresolved name.</p>
<h2 id="unresolvedref"><a class="header" href="#unresolvedref"><code>UnresolvedRef</code></a></h2>
<p>This class contains mutable state in its field <code>resolvedDecl</code>, which can be filled by calling <code>UnresolvedRef.resolve</code>. Most occurences of <code>Ref</code> have an entry in <code>ResolveReferences</code>, but it is not clear that there is always a sensible way to implement this.</p>
<h2 id="referrable"><a class="header" href="#referrable"><code>Referrable</code></a></h2>
<p>Any other situation should just remember the text name from the input in a node, and contain mutable state that receives the result of resolving it. By convention, this is a <code>var ref: Option[?] = None</code>. Other code like <code>check</code> and <code>t</code> may assume the <code>ref</code> is filled.</p>
<p>Usually the resolution result points to something in the AST, in which case you should use <code>Referrable</code>. It can point to the following kinds of thing:</p>
<ul>
<li>Exactly one <code>Declaration</code>;</li>
<li>A portion of a declaration, such as field #2 in the multi-declaration <code>int x, y, z;</code>;</li>
<li>A reference to an intrinsic part of the language that cannot be directly parsed, such as cuda's <code>blockDim</code>;</li>
<li>A reference to a VerCors-built-in concept, like the <code>.size</code> of a sequence;</li>
<li>A reference to a construct that exists implicitly, such as Java's default constructor.</li>
</ul>
<p>It is a bit frustrating that all declarations are essentially duplicated under <code>Referrable</code>, but it does give us the flexibility to make names point to whatever we want.</p>
<h2 id="from-col-tree-to-resolved-tree"><a class="header" href="#from-col-tree-to-resolved-tree">From COL tree to resolved tree</a></h2>
<p>When using an <code>UnresolvedRef</code> or adding a <code>Option[Referrable]</code> variable, we should take care that an appropriate entry is added in <code>Resolve{References,Types}.resolveOne</code>. We split out the resolution by language (including the specification language), which usually derives an appropriate <code>Referrable</code> from the <code>{Type,Reference}ResolutionContext</code>. Note again that we are allowed to e.g. query the type of child nodes, which is very relevant in resolving e.g. instance methods.</p>
<h2 id="from-resolved-tree-to-ref"><a class="header" href="#from-resolved-tree-to-ref">From resolved tree to <code>Ref</code></a></h2>
<p>The companion rewriters <code>LangTypesToCol</code> and <code>LangSpecificToCol</code> translate resolved references into a <code>Ref</code> (that is not an <code>UnresolvedRef</code>). From then on references are defined only by pointing at the declaration it resolved. A consequence of this is that past the language-specific pass pointing to anything other than exactly one declaration as above is not possible.</p>
<p>Note: the <code>LangSpecificToCol</code> pass has accumulated far too much logic. The ideal path to implement a feature in VerCors is that you design new concepts in the core of COL that you need, and figure out a straightforward way to map to it in <code>LangSpecificToCol</code>. The task of <code>LangSpecificToCol</code> is not to lower language features into low-level concepts immediately, and VerCors often benefits from well-designed features in the core of COL across front-ends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewriting"><a class="header" href="#rewriting">Rewriting</a></h1>
<p>The main activity of VerCors is rewriting a program. We use the concept of a <code>Rewriter</code> to structure the transformation of a program tree in an understandable and disciplined manner.</p>
<p>A rewriter recurses into one tree, and calls <a href="./rw-dispatch.html">dispatch</a> for each element of the tree by default. To ensure that each part of the tree is actually rewritten, we use the concept of <a href="./rw-generation.html">generations</a> to make the prior tree and the new tree have unrelated types. Declarations are a bit special: each declaration need not be <a href="./rw-succession.html">succeeded</a> by exactly one declaration of the same kind â€” as opposed to structural nodes. By transforming a program tree the verification failures that may occur in the program change, so we explain how to transform the errors to be about the input by providing <a href="./rw-blame.html">blames</a>.</p>
<p>The later sections describe concepts that are more advanced, and require careful consideration to whether they are appropriate. <a href="./rw-nested.html">Nested rewriters</a> can be used when the rewriting behaviour materially changes when recursing into a certain node. It can be confusing to read, because you might intuit that the patterns in the parent rewriter are still used, when they are not. <a href="./rw-substitution.html">Substitution</a> can be helpful if your rewriting process is effectively two-step, but it is more straightforward to glue on a simple behavior to one rewriter. Nevertheless it is often actually better to consider explicitly how you might model the substitution statefully anyway: this gives a clearer picture what should happen when e.g. nodes needing subtitution are nested.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outline"><a class="header" href="#outline">Outline</a></h1>
<p>When implementing a new rewriter you should make a class that extends <code>Rewriter</code>. Additionally it should have a companion object that extends <code>RewriterBuilder</code>: other than giving a <code>key</code> and <code>desc</code> to present to the user, it describes how to construct a rewriter with <code>apply</code>. The <code>apply</code> method is defined implicitly if you make your rewriter a <code>case class</code>.</p>
<p>The outline of an empty rewriter then looks like this:</p>
<pre><code class="language-scala">package vct.col.rewrite

import vct.col.ast._
import vct.col.rewrite.{Generation, Rewriter, RewriterBuilder}
import vct.col.util.AstBuildHelpers._

case object MyRewriter extends RewriterBuilder {
  override def key: String = "my"
  override def desc: String = "Apply a transformation to the COL tree"
}

case class MyRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
  
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h1>
<p>A rewriter describes how a COL tree is transformed. The root of the tree is passed to one of the <code>dispatch</code> methods: each <code>dispatch</code> method decides what should happen next. By default we always recurse into the tree, querying <code>dispatch</code> for the child nodes of our current node. You might imagine that the default implementation of <code>dispatch</code> for a <code>Plus</code> node is structured like this:</p>
<pre><code class="language-scala">def dispatch(e: Expr[Pre]): Expr[Post] =
  e match {
    case Plus(left, right) =&gt;
      Plus(dispatch(left), dispatch(right))(e.o)

    /* ... other alternatives ... */
  }
</code></pre>
<h2 id="structural-transformations"><a class="header" href="#structural-transformations">Structural transformations</a></h2>
<p>The idea is now that you override dispatch methods for the nodes you would like to rewrite. For example, we might want to make an optimization that simplifies away additions of <code>0</code>:</p>
<pre><code class="language-scala">val ZERO = BigInt(0)

override def dispatch(e: Expr[Pre]): Expr[Post] =
  e match {
    case Plus(IntegerValue(ZERO), e) =&gt; dispatch(e)
    case Plus(e, IntegerValue(ZERO)) =&gt; dispatch(e)

    case other =&gt; other.rewriteDefault()
  }
</code></pre>
<p>A new concept here is <code>rewriteDefault</code>: it is the mechanism used to peel off one layer of a program tree and recurse into its children using dispatch. It is automatically generated for each node, here in <code>PlusRewrite</code>. It takes an implicit value of type <code>AbstractRewriter</code>, which is the rewriter used to call <code>dispatch</code> again. By default it picks the <code>implicit val rewriter</code> which is defined for each <code>AbstractRewriter</code>. Note that Scala requires that a match statement is complete. A default case as above also makes the match complete.</p>
<p>A common mistake is to erroneously call <code>rewriteDefault</code> too often: when recursing into nodes yourself you should almost always call <code>dispatch</code>, which will decide to do with the sub-node.</p>
<h2 id="transforming-declarations"><a class="header" href="#transforming-declarations">Transforming Declarations</a></h2>
<p><em>See also: <a href="./rw-succession.html">Succession</a></em></p>
<p>Declarations are special because it is not required that a declaration is transformed into a declaration. This is also represented in the signature of the <code>dispatch</code> method for <code>Declaration[_]</code>:</p>
<pre><code class="language-scala">def dispatch(decl: Declaration[Pre]): Unit
</code></pre>
<p>Nevertheless declarations have to be placed in the tree, and references to declarations need to be rewritten. Both are arranged through an instance of the <code>Scopes</code> class â€” one for each kind of declaration. Rewriting references is tricky, so this is explained later on in the section on <a href="./rw-succession.html">succession</a>.</p>
<p>A node that contains declaration, such as <code>Class[G](decls: Seq[ClassDeclaration[G]], ...)</code>, needs to come up with a new list of <code>ClassDeclaration[G]</code>. We first have to consider the appropriate <code>Scopes</code> instance: in this case <code>classDeclarations</code>. We call <code>classDeclaration.collect</code>, which pushes a collection buffer onto a stack. A lambda is passed to <code>collect</code> in which we can take any actions, chiefly to declare declarations of kind <code>ClassDeclaration</code>. By convention we call <code>dispatch</code> on all the <code>Pre</code>-state declarations that we are interested in, and (optionally) we can declare one or more other <code>ClassDeclaration</code>s we need to add. All this is also allowed to happen recursively: we can be in a statement somewhere in the class and still declare a helper method to the <code>classDeclarations</code> scope.</p>
<p>Combining this information we can obtain the new declarations of a class as such:</p>
<pre><code class="language-scala">val newDeclarations = classDeclarations.collect {
  cls.decls.foreach(dispatch)
}._1
</code></pre>
<p>Collect returns a tuple: a list of new declarations, and whatever the result of the lambda is (here: <code>Unit</code>). On the other side of the fence, the old class declarations are rewritten and declared to the scope. Reproducing the default behaviour for <code>ClassDeclaration</code>s might look like this, skipping over succession for the moment:</p>
<pre><code class="language-scala">override def dispatch(decl: Declaration[Pre]): Unit =
  decl match {
    case decl: ClassDeclaration[Pre] =&gt;
      classDeclarations.declare(decl.rewriteDefault())

    case other =&gt;
      allScopes.anyDeclare(other.rewriteDefault())
  }
</code></pre>
<p>Our friend <code>rewriteDefault</code> makes another appearence, which peels off the <code>ClassDeclaration</code> constructor, and recurses into its components. In the case that a <code>ClassDeclaration</code> contains further declarations, it will call <code>collect</code> again in a similar way. For example, an <code>InstanceMethod</code> is a <code>ClassDeclaration</code> and contains declarations of kind <code>Variable</code> for its arguments.</p>
<p>After rewriting the declaration fully by opting to rewrite it in a one-to-one manner, it is declared to the buffer of <code>ClassDeclaration</code>s that we are currently collecting.</p>
<p>Lastly we must always complete the match, which is done by also rewriting other declarations one-to-one, and using <code>allScopes</code> to find the correct scope to put the declaration in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generations"><a class="header" href="#generations">Generations</a></h1>
<p>You may have noticed by now that each node carries with it a type parameter, usually denoted <code>G</code>, <code>Pre</code> or <code>Post</code>. This type parameter is not used or stored anywhere in the tree, and due to type erasure it is in fact entirely compiled away: it has no operational effect in the tool. Instead it is a facility by which we can make COL trees have entirely disjoint types. We maintain by hand the invariant that the subnodes of each node have the same "generation" type parameter as the node itself in the node declarations. Each node declares a type parameter <code>G</code>, which is passed along in all node types that the node contains.</p>
<p>All normal tree operations make sense as long as the generation type parameter matches between trees: we can take a tree of type <code>Node[G]</code>, and replace all occurences of a <code>Local[G]</code> with an <code>Expr[G]</code>. On the other hand, there is no way to place a tree of type <code>Node[L]</code> in a tree of type <code>Node[R]</code> (unless <code>L</code> and <code>R</code> resolve to the same type).</p>
<p>This trick is useful in rewriters: we make the input tree type unrelated to the output tree type. The input node type uses <code>Pre</code> for the generation, whereas the output uses <code>Post</code>. This makes it so that you cannot return an input tree as though it is an output tree: you are required to rewrite the input explicitly. Although it is possible that optimizations exist where it would not be necessary to recurse into a particular type of tree, we find that eventually it becomes necessary anyway. A short parable: contract expressions are pure, so we should not have to rewrite them if we are only transforming method invocations (a side effect). Afterwards we add a feature where a method can be marked <code>/*@ pure */</code>, which translates the method to a pure function. It should afterwards be possible to use this method in contract expressions, but this introduces a bug at great distance in our original rewriter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="succession"><a class="header" href="#succession">Succession</a></h1>
<p><em>See also: <a href="./rw-dispatch.html#transforming-declarations">Transforming Declarations</a></em></p>
<p>The succession system is a pure convenience: it accounts when there is exactly one canonical successor of a declaration, then uses that successor to rewrite references to the declaration. When rewriting a declaration is left to the default dispatch implementation, there is always one canonical successor: the declaration it is rewritten into. This can be witnessed in the default implementation of <code>dispatch</code> for declarations, which is defined in <code>NonLatchingRewriter</code>:</p>
<pre><code class="language-scala">override def dispatch(decl: Declaration[Pre]): Unit =
  allScopes.anySucceed(decl, decl.rewriteDefault())
</code></pre>
<p>The method <code>anySucceed</code> both declares the new declaration, and accounts it as the successor of the old declaration. In the rare case that you need to only account the successor of the declaration, but not declare it, you can call <code>anySucceedOnly</code> instead.</p>
<p>Note it is typically not necessary to use <code>allScopes</code>: it is simply a dispatcher for the scopes by declaration kind, like <code>globalDeclarations</code>, <code>classDeclarations</code>, etc. For example, you can declare and account the successor of a procedure as such:</p>
<pre><code class="language-scala">globalDeclarations.succeed(oldProc, newProc)
</code></pre>
<h2 id="rewriting-references"><a class="header" href="#rewriting-references">Rewriting references</a></h2>
<p>The default way of rewriting any reference is to query the successor of the declaration it refers to. Note that this is by default always done lazily: the succession accounting may be delayed until the first time the reference is queried with <code>_.decl</code>.</p>
<p>There is no obligation to always use an instance of <code>Scopes</code> to account successors. For convenience you can opt to use <code>SuccessionMap</code>, which is a thin layer over a thread-safe regular map that allows the construction of <code>Ref</code>s that query the map lazily, and provide some useful error otherwise. Even this is not mandatory: you can choose to use e.g. a <code>mutable.Map</code> instead if you want. It is however important to remember the law of succession:</p>
<blockquote>
<p>When the successor of a declaration is not accounted, you must consider <strong>all</strong> positions that can reference that kind of declaration.</p>
</blockquote>
<p>Luckily for most kinds of declarations there are not that many nodes that can refer to it. It is helpful to consider that references to a broad type are extremely sparse. In particular, nearly all references at least stay within the type of its kind (e.g. <code>ClassDeclaration[G]</code>, <code>GlobalDeclaration[G]</code>) and the vast majority refer to a leaf type.</p>
<h2 id="scoping"><a class="header" href="#scoping">Scoping</a></h2>
<p>The successor of a declaration is visible only in the scope that the declaration itself is visible. For example: it does not make sense to ask about the successor of a local variable, if the variable belongs to a different method. What this enables is the simple-sounding property that it is usually safe to rewrite a node twice: the successors accounted in the second rewrite do not clobber the successors accounted in the first rewrite, because they are scoped correctly. We call nodes for which it is safe to rewrite them twice duplicable.</p>
<p>Most structural nodes are duplicable, and declarations are themselves not duplicable: you are not allowed to overwrite the successor of a declaration within one scope. Note that structural nodes that <em>contain</em> declarations (e.g. <code>Program</code>, <code>Forall</code>) are usually duplicable. The property that determines whether a node is duplicable is as such: whenever a declaration can (transitively) occur in a node, it must have a parent Node that <code>@scopes</code> that kind of declaration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blames"><a class="header" href="#blames">Blames</a></h1>
<p>One of the core tenets of VerCors is that technical verification errors are translated as precisely as possible to a problem in the input to the tool.</p>
<p>We submit a large query with many verification goals to our backend, Viper, and receive back a list of errors. This list is translated backwards to relate to the input through the blame system: each node that induces a verification goal must explain what to do with the error. The most common way to explain away an error is to just blame somebody else! Each rewriter gets an input tree, along with blames for each goal-inducing node. On the output side, we have to provide the blame instead, but for simpler rewrites there usually is an apparent blame we can use from the input side.</p>
<h2 id="blaming-somebody-else"><a class="header" href="#blaming-somebody-else">Blaming somebody else</a></h2>
<p>If the type of error on the input and output side are the same, we can simply place the blame in the output tree without rewriting it â€” blames are special in this sense. A slight complication occurs when the type does not match. For example, we might be tranlating a well-formedness condition like <code>Blame[MapKeyError]</code> to a function precondition blame of type <code>Blame[InvocationFailure]</code>.</p>
<p>In this case we have to indicate how the error is translated:</p>
<pre><code class="language-scala">case class MapKeyPreconditionFailed(get: MapGet[_]) extends Blame[InvocationFailure] {
  override def blame(error: InvocationFailure): Unit =
    error match {
      case PreconditionFailed(_, _, _) =&gt;
        get.blame.blame(MapKeyError(get))
      case ContextEverywhereFailedInPre(_, _) =&gt;
        PanicBlame("This rewriter does not generate context_everywhere clauses for map get functions")
          .blame(error)
    }
}
</code></pre>
<p>If the precondition of the function fails in some position, we translate the error to be the original well-formedness conditions on a map get operation.</p>
<h2 id="blaming-the-system"><a class="header" href="#blaming-the-system">Blaming the system</a></h2>
<p>We declare that it is impossible that <code>ContextEverywhereFailedInPre</code> occurs, because we guarantee in the rewriter that the <code>context_everywhere</code> clause of the function we generate is <code>true</code>. It is important that we do not just silence the error.</p>
<p>Note: Although this style of blame transformation works, it is too easy to silence errors this way. In fact: this snippet would still compile if the <code>PanicBlame</code> line was omitted entirely. We should consider making blames functional: it should return a (list of) errors instead of invoking a further blame explicitly.</p>
<h2 id="blaming-everybody-else"><a class="header" href="#blaming-everybody-else">Blaming everybody else</a></h2>
<p>For some positions where a contract is specified, you can also depend on what part of the contract is false. You can find these positions through the fact that they contain an <code>AccountedPredicate[G]</code> instead of an <code>Expr[G]</code>. They additionally report a sequence of <code>AccountedDirection</code> in the appropriate failure, which you can match on in the blame. In fact: you need to be careful to ensure that when the shape of an <code>AccountedPredicate</code> changes, the matching <code>blame</code> needs to also account for the changed shape.</p>
<p>Typically a contract expression is added to the start or end of an accounted predicate. For example, <code>context_everywhere</code> is transated to be a regular pre- and postcondition as such:</p>
<pre><code class="language-scala">contract.rewrite(
  contextEverywhere = tt,
  requires = SplitAccountedPredicate(
    UnitAccountedPredicate(freshInvariants()),
    dispatch(contract.requires),
  ),
  ensures = SplitAccountedPredicate(
    UnitAccountedPredicate(freshInvariants()),
    dispatch(contract.ensures),
  ),
)
</code></pre>
<p>Here the <code>context_everywhere</code> specifications are prepended, so we have to call the original blame when the accounted predicate path starts with <code>FailRight</code>:</p>
<pre><code class="language-scala">inv.rewrite(blame =
  PreBlameSplit
    .left(ContextEverywherePreconditionFailed(inv), inv.blame)
)
</code></pre>
<p>Note that although there is only a few places where <code>AccountedPredicate</code> is used, this is really only for convenience: there is no strong reason to keep e.g. loop invariants an <code>Expr</code> other than convenience.</p>
<h2 id="blaming-the-user"><a class="header" href="#blaming-the-user">Blaming the user</a></h2>
<p>So far we have looked at blames that blame other blames, but they do come from somewhere. All the transformations of parse trees to COL trees keep around a <code>blameProvider</code>, which explains how to create the initial blame. Note: although the constructed blame can optionally depend on the position, this is not usually used to determine the location at the source. Instead, the origin of the relevant node in the <code>VerificationFailure</code> is typically used. This design is a bit shaky and should be reviewed.</p>
<p>This process of constructing an initial blame is <strong>only</strong> done in the parse tree stage: from then on new blames are not created. The typical way to provide blame is to pass a <code>ConstantBlameProvider</code> that gives out a constant <code>BlameCollector</code> for every blame: a facility that simply stores a list of <code>VerificationFailure</code>s in a buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-rewriters"><a class="header" href="#nested-rewriters">Nested Rewriters</a></h1>
<p>Occasionally it can be useful to nest rewriters. It essentially divorces the rewriting rules entirely from the parent rewriter when you invoke the nested rewriter. This means that any match arms or other logic in <code>dispatch</code> implementations in the parent rewriter are not used when inside the nested rewriter.</p>
<p>It is rare that a nested rewriter is actually what you want: usually it is more explicit and clear to account the desired behaviour with a piece of state in one rewriter. As an example we can consider the rewriter that collects inline patterns of quantifiers: its task is to scan for any patterns that occur on the inside of a quantifier marked with <code>{: ... :}</code>, and apply them as triggers for the quantifier. It may be tempting to do this with a rewriter: we ignore patterns while recursing into the tree until we encounter e.g. a <code>Forall</code>, and then our behaviour changes entirely: we instead remove patterns and collect them into some buffer â€” why not rewrite the body of the quantifier with a nested rewriter?</p>
<p>The problem becomes apparent when you consider that a <code>Forall</code> can also contain a nested <code>Forall</code>. When scanning for patterns we encounter a nested <code>Forall</code> while in the nested rewriter. Do we call to the outer rewriter again? We can apply another nesting level in the rewriter, but where do we save patterns that are in the nested <code>Forall</code>? What if we add support for triggers for <code>Exists</code>, do we add the pattern in both places?</p>
<p>Instead of implementing this behaviour with a nested rewriter it is more straightforward to maintain a stack of buffers that collect patterns, and have the match arm for <code>Forall</code> and <code>InlinePattern</code> on the same level. <code>Forall</code> puts a collection buffer on the stack, whereas <code>InlinePattern</code> adds itself to the buffer on the top of the stack. It is a bit more explicit and stateful, but in actuality it is a better admission of how your rewriter is structured: a nested rewriter just thinly veils this state.</p>
<h2 id="declaring-a-nested-rewriter"><a class="header" href="#declaring-a-nested-rewriter">Declaring a nested rewriter</a></h2>
<p>By convention a nested rewriter is usually declared inside the parent rewriter it is used in:</p>
<pre><code class="language-scala">case class OuterRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
	case class NestedRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
		// ...
	}
}
</code></pre>
<p>The only thing that is immediately necessary to consider is that of scopes. When communicating a tree from the parent to the nested rewriter, or vice versa, it is important that the rewriters agree on how to arrange declarations, and whether succession records in the nested rewriter are visible to the parent rewriter.</p>
<p>The most straightforward way to arrange scopes and succession is to just let the nested rewriter inherit the <code>allScopes</code> field of the parent rewriter:</p>
<pre><code class="language-scala">case class OuterRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
	outer =&gt;

	case class NestedRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
		override val allScopes = outer.allScopes
	}
}
</code></pre>
<p>This is the only reasonable option if it is required that the nested rewriter returns a tree of the <code>Post</code> generation. There is more flexibility if you can accept that the nested rewriter returns a <code>Pre</code>-tree. For example, the <code>Substitute</code> utility has an entirely fresh <code>allScopes</code> and uses it of declarations inside the tree that is being substituted, but returns references to declarations as-is when the successor is not known inside the substitution:</p>
<pre><code class="language-scala">case class Substitute[G](/* ... */) extends NonLatchingRewriter[G, G] {

  case class SuccOrIdentity() extends SuccessorsProviderTrafo[G, G](allScopes) {
    override def postTransform[T &lt;: Declaration[G]](
        pre: Declaration[G],
        post: Option[T],
    ): Option[T] = Some(post.getOrElse(pre.asInstanceOf[T]))
  }

  override def succProvider: SuccessorsProvider[G, G] = SuccOrIdentity()

  /* ... */
}
</code></pre>
<p>Notice that <code>Substitute</code> is thus not suitable when subtituting a tree that contains declarations that must be scoped <em>outside</em> the tree that is being substituted. This is explained further in <a href="./rw-substitute.html">Substitution</a>.</p>
<p>Another option is to recognize that the declarations of the tree being rewritten are entirely disjoint from the parent tree. This means that there are no references from the parent to the subtree, or from the subtree to the parent. An example of this is the simplifier: it loads rules from a file, which of course cannot contain a reference to the tree being simplified, nor can the subject tree refer to simplification rules it has not loaded. Thus: rewriting a rule in a nested rewriter with fresh scopes is perfectly fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<p>This chapter describes a few utilities included with VerCors. A fair few utilities are implemented as a middleware:</p>
<h2 id="middleware"><a class="header" href="#middleware">Middleware</a></h2>
<p>A middleware for VerCors is a concern that is cross-cutting, needs installing and potentially cleanup after finishing, and needs to be accessible globally for convenience. Examples of middlewares in VerCors are: logging, profiling, and progress printing. All have a start and an end with installation logic and cleanup, and it would be wildly inconvenient if we had to pass around a profiling object everywhere in the tool.</p>
<p>The motivation for making middleware an explicit abstraction is twofold:</p>
<h3 id="lsp"><a class="header" href="#lsp">LSP</a></h3>
<p>Middleware will enable us to swap in different implementaitons for logging, progress, etc. when we implement VerCors as a language server. Currently middlewares are immediately implemented as a class, but we can easily fit an interface inbetween, and install different middlewares when in console mode or LSP mode.</p>
<h3 id="crashing-and-all-that"><a class="header" href="#crashing-and-all-that">Crashing and all that</a></h3>
<p>It is helpful that certain clean-up tasks happen irrespective of whether VerCors finishes normally, the process is interrupted via Ctrl+C, or VerCors crashes. Finishing normally and crashing could harmonize middleware cleanup via a <code>finally</code> block, but this is not the case for stopping VerCors with Ctrl+C (and other signals). The only way to have clean-up behaviour in that case is to register a shutdown hook. The middleware abstraction simply makes this uniform: uninstall tasks always run, and they run in reverse order of how they were installed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>The <code>hre.cache.Cache</code> utility allows you to create an on-disk cache directory that is determined by a specified list of keys. There is also a facility to tie the cache directory only to the process that the cache is being requested in, essentially reducing the cache directory to a temporary directory.</p>
<h2 id="usages"><a class="header" href="#usages">Usages</a></h2>
<p>There are a few usages of caching:</p>
<ul>
<li>In <code>vct.cache.Caches</code> a directory is made to cache verification results from carbon and silicon. This behaviour is guarded behind the experimental option <code>--dev-cache</code>. An entry is stored in the cache if a program has no verification failures, in which case the program is serialized to disk.</li>
<li>In <code>vct.cache.Caches</code> there is a directory that caches the result of parsing, resolving and normalizing a library file writting in PVL. This is used for e.g. simplification rules and datatype definitions. The result is serialized to disk.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
