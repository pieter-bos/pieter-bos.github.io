<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>VerCors Development Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Quick reference guide</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.1.</strong> Adding a Language</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> New specifications</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> New modes</div></li></ol></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Techical Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup-workflow.html"><strong aria-hidden="true">2.1.</strong> Workflow</a></li><li class="chapter-item expanded "><a href="setup-language.html"><strong aria-hidden="true">2.2.</strong> Language</a></li><li class="chapter-item expanded "><a href="setup-build-system.html"><strong aria-hidden="true">2.3.</strong> Build System</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Libraries</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.1.</strong> ANTLR</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.2.</strong> Logback</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="col.html"><strong aria-hidden="true">3.</strong> Common Object Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="col-nodes.html"><strong aria-hidden="true">3.1.</strong> Nodes</a></li><li class="chapter-item expanded "><a href="col-ref.html"><strong aria-hidden="true">3.2.</strong> References</a></li><li class="chapter-item expanded "><a href="col-origin.html"><strong aria-hidden="true">3.3.</strong> Origins</a></li><li class="chapter-item expanded "><a href="col-check.html"><strong aria-hidden="true">3.4.</strong> Checking</a></li><li class="chapter-item expanded "><a href="col-coercion.html"><strong aria-hidden="true">3.5.</strong> Coercion</a></li><li class="chapter-item expanded "><a href="col-pp.html"><strong aria-hidden="true">3.6.</strong> Pretty-Printing</a></li><li class="chapter-item expanded "><a href="col-compare.html"><strong aria-hidden="true">3.7.</strong> Comparing</a></li><li class="chapter-item expanded "><a href="col-serialize.html"><strong aria-hidden="true">3.8.</strong> Serialization</a></li></ol></li><li class="chapter-item expanded "><a href="resolution.html"><strong aria-hidden="true">4.</strong> Resolution</a></li><li class="chapter-item expanded "><a href="rw.html"><strong aria-hidden="true">5.</strong> Rewriting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rw-outline.html"><strong aria-hidden="true">5.1.</strong> Outline</a></li><li class="chapter-item expanded "><a href="rw-dispatch.html"><strong aria-hidden="true">5.2.</strong> Dispatch</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Generations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Succesion</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Blames</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Nested Rewriters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Substitution</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> RewriteHelper</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> RewriteBuilder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Backend and Errors</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Program Translation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Error Translation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Utilites</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Caching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Profiling and Progress</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Importing</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VerCors Development Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Were you linked here, but not sure where to start? Maybe try a quick reference guide:</p>
<ul>
<li><a href="start-language.html">Adding a new input language to VerCors</a></li>
<li><a href="start-spec.html">Add a new type of specification to VerCors</a></li>
<li><a href="start-mode.html">Making VerCors do something other than verifying files</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>VerCors is a tool that tries to show programs to be correct. Correct may mean that the program finishes, that it does not crash, that it never throws an exception, or returns the correct result subject to some specification.</p>
<p>VerCors accepts programs in a variety of languages. For each language (also: <em>frontend</em>) the grammar is altered slightly, maintaining compatiblity with the source langauge grammar, so that we may add various annotations to the program. These annotations aid in verifying the program by specifying behaviour about it. This is crucial in automating the proof of the program.</p>
<p>As a tool VerCors works by passing the program through a large number of transformations. In general each transformation reduces the number of <em>features</em> in the program. You may think about features as different kinds of statements and operators. Various concerns are maintained in each element of the transformation. The most important guarded invariant is that of error transformations. As statement \(P\) is compiled into a different statement \(Q\), we have to remember how to translate errors about statement \(Q\) back into errors about statement \(P\).</p>
<p>An intermediate program is stored in VerCors as an <em>Abstract Syntax Tree</em> (short: AST). The internal language is also referred to as the <em>Common Object Language</em> (short: COL). Each part of the transformation is structured as a <em>Rewriter</em>, which visits each element in the AST. After visiting a node in the tree, the rewriter must specify what that node is replaced with. By default, the rewriter will recurse further into the tree, keeping the kind of node the same. For example, if we ask a default rewriter what \(p + q\) must be rewritten to, we will then ask what \(p\) and \(q\) will rewrite to. Supposing they rewrite to \(p'\) and \(q'\) respectively, the rewriter will by default restore the plus operator and return \(p' + q'\).</p>
<p>Around the transformation chain there are several steps. Unfortunately, syntax trees do not fall out of thin air, so we must first parse our text input into a tree. In VerCors, this is largely handled by by the ANTLR parser generator. We translate parse trees into COL trees as a part of the parsing stage, but there are no surprises there: as a matter of principle there is a corresponding COL node for each parse node. Next there is resolution: the process of associating each name in the tree with a referrable node. For example, variable names 'point' to the declaration of the variable. This stage usually presupposes that the file compiles at all.</p>
<p>After all the transformations we have a very simple program. On the other hand, proving it to be correct is no simple matter. We delegate this responsibility to Viper, a tool designed to automatically verify this dialect of program. Finally, a (hopefully empty) list of errors from Viper is translated into appropriate errors for the initial input to VerCors.</p>
<p>This completes the intended cycle of usage for VerCors: submitting a program to VerCors leads to a list of suggested improvements, which leads to editing the program, which leads to a new submission to VerCors. We have some qualitative wishes here: errors should be clear, specific and not a false negative. It should include context where appropriate, such as an example of how the error might occur. Ideally, VerCors is performant and can quickly establish whether or not there is an error.</p>
<p>The central goal is that we can encourage writers of critical software to prove their programs to be correct, so that their software is reliable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Were you linked here, but not sure where to start? Maybe try a quick reference guide:</p>
<ul>
<li><a href="start-language.html">Adding a new input language to VerCors</a></li>
<li><a href="start-spec.html">Add a new type of specification to VerCors</a></li>
<li><a href="start-mode.html">Making VerCors do something other than verifying files</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>VerCors is a tool that tries to show programs to be correct. Correct may mean that the program finishes, that it does not crash, that it never throws an exception, or returns the correct result subject to some specification.</p>
<p>VerCors accepts programs in a variety of languages. For each language (also: <em>frontend</em>) the grammar is altered slightly, maintaining compatiblity with the source langauge grammar, so that we may add various annotations to the program. These annotations aid in verifying the program by specifying behaviour about it. This is crucial in automating the proof of the program.</p>
<p>As a tool VerCors works by passing the program through a large number of transformations. In general each transformation reduces the number of <em>features</em> in the program. You may think about features as different kinds of statements and operators. Various concerns are maintained in each element of the transformation. The most important guarded invariant is that of error transformations. As statement \(P\) is compiled into a different statement \(Q\), we have to remember how to translate errors about statement \(Q\) back into errors about statement \(P\).</p>
<p>An intermediate program is stored in VerCors as an <em>Abstract Syntax Tree</em> (short: AST). The internal language is also referred to as the <em>Common Object Language</em> (short: COL). Each part of the transformation is structured as a <em>Rewriter</em>, which visits each element in the AST. After visiting a node in the tree, the rewriter must specify what that node is replaced with. By default, the rewriter will recurse further into the tree, keeping the kind of node the same. For example, if we ask a default rewriter what \(p + q\) must be rewritten to, we will then ask what \(p\) and \(q\) will rewrite to. Supposing they rewrite to \(p'\) and \(q'\) respectively, the rewriter will by default restore the plus operator and return \(p' + q'\).</p>
<p>Around the transformation chain there are several steps. Unfortunately, syntax trees do not fall out of thin air, so we must first parse our text input into a tree. In VerCors, this is largely handled by by the ANTLR parser generator. We translate parse trees into COL trees as a part of the parsing stage, but there are no surprises there: as a matter of principle there is a corresponding COL node for each parse node. Next there is resolution: the process of associating each name in the tree with a referrable node. For example, variable names 'point' to the declaration of the variable. This stage usually presupposes that the file compiles at all.</p>
<p>After all the transformations we have a very simple program. On the other hand, proving it to be correct is no simple matter. We delegate this responsibility to Viper, a tool designed to automatically verify this dialect of program. Finally, a (hopefully empty) list of errors from Viper is translated into appropriate errors for the initial input to VerCors.</p>
<p>This completes the intended cycle of usage for VerCors: submitting a program to VerCors leads to a list of suggested improvements, which leads to editing the program, which leads to a new submission to VerCors. We have some qualitative wishes here: errors should be clear, specific and not a false negative. It should include context where appropriate, such as an example of how the error might occur. Ideally, VerCors is performant and can quickly establish whether or not there is an error.</p>
<p>The central goal is that we can encourage writers of critical software to prove their programs to be correct, so that their software is reliable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="techical-setup"><a class="header" href="#techical-setup">Techical Setup</a></h1>
<p>This chapter describes some of the technical setup around vercors, like version control, programming language choice, and libraries. It can be referred back to when evaluating changes to the setup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow"><a class="header" href="#workflow">Workflow</a></h1>
<p>Since VerCors is made by Real Humansâ„¢ we agreed on some administrative conventions to stick by:</p>
<ul>
<li>If you have a bug or clearly delineated feature request, it should exist as an issue on our tracker on GitHub: <a href="https://github.com/utwente-fmt/vercors/issues">https://github.com/utwente-fmt/vercors/issues</a>. The goal is to have zero issues: that should be achievable, since it should be clear what to do from the issue.</li>
<li>If you have a more vague feature request, or a question, or you're not sure if something is a bug, it should be a discussion: <a href="https://github.com/utwente-fmt/vercors/discussions">https://github.com/utwente-fmt/vercors/discussions</a>.</li>
<li>If you're working on VerCors code longer term, we prefer that you do so in a <em>branch</em> in the main repository, rather than working in a fork. Please ask for push access when starting out.</li>
<li>If you're working on a single issue, please assign yourself the issue.</li>
<li>We use feature branches and pull requests, so once you're done please file a pull request. Contiuous integration will run all examples on your changes automatically, so it's wise to check if it succeeded.</li>
<li>We do not have a linting policy at this time. We ask that try to follow local conventions of files you're editing and do not reformat whole files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>VerCors is a JVM project, and the current main language we use is Scala. We do accept contributions in both Scala and Java, but we highly encourage you to learn some Scala before contributing.</p>
<p>Since the main backend of VerCors is currently Viper, we enjoy the benefit of calling into it directly and being able to debug it directly, since VerCors is also a JVM application.</p>
<p>We primarily develop VerCors in Scala for several reasons:</p>
<ul>
<li>Scala has great support for functional programming paradigms. VerCors primarily deals with immutable data-structures and pushes out effects, like logging verification failures and writing out files.</li>
<li>Scala supports pattern matching, which is very suitable for analysing ASTs.</li>
<li>Scala supports metaprogramming, which is very handy for generating functionality that recurses into the ASTs: rewriters, comparators, etc.</li>
<li>Other nice to haves: good collection api (sequences, sets), optional structural equality, sealed types.</li>
</ul>
<p>On the surface it seems Kotlin has significant feature overlap with Scala, but some of the above points are not available and are important. We may revisit that stance in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-system"><a class="header" href="#build-system">Build System</a></h1>
<p>The default build system for Scala, and hybrid Scala/Java project, is SBT. However, our current build system is <a href="https://mill-build.com/">mill</a>. For a general overview of why we don't use SBT anymore, see <a href="http://www.lihaoyi.com/post/SowhatswrongwithSBT.html">here</a>.</p>
<p>For us specifically we considered these things:</p>
<ul>
<li>For meta-build alterations in ColHelper, it was annoying to remember that you need to reload.</li>
<li>You needed to alter the IntelliJ settings immediately, otherwise the project does not build by default.</li>
<li>The run script broke for almost every user, because we use a custom classpath caching solution, because sbt "run example.pvl" starts up way too slow (~7 seconds when vercors is already entirely compiled).</li>
<li>Most people had encountered a situation where the project just breaks, and you need to re-import everything.</li>
<li>Anything custom was hard to implement, because we didn't understand enough about how sbt works.</li>
</ul>
<p>Mill on the other hand does not have these drawbacks:</p>
<ul>
<li>It is almost just scala.</li>
<li>Tasks are a straightforward and easy abstraction:
<ul>
<li>Custom stuff is easy to implement, even when interacting with mill internals.</li>
<li>Caching is essentially free due to the data model.</li>
<li>Tooling around mill is easy, because the hierarchy in the build definition corresponds to the hierarchy in <code>out</code>.</li>
<li>You can chain tasks entirely as you like and mill is fine with it: e.g. <code>col.generatedSources</code> depends on <code>colMeta.meta.runClasspath</code>.</li>
</ul>
</li>
<li>Mill boots with the vercors build in under one second, e.g. <code>time ./mill -j 0 vercors.runScript</code> -&gt; <code>real 0m0,753s</code>
<ul>
<li>This means we can finally get rid of our own classpath abstraction: we can be sure vercors runs normally every time.</li>
</ul>
</li>
<li>Mill seems to work well with IntelliJ via the BSP integration, which does not need any altered settings in IntelliJ.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-object-language"><a class="header" href="#common-object-language">Common Object Language</a></h1>
<p>The Common Object Language (short: COL) is the intermediate representation of VerCors. The main component of VerCors is to apply a sequence of transformations (rewriters) to the COL tree until it is suitable to submit to a backend. This chapter describes concepts around the structure of COL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>COL programs are stored in a tree-like immutable data structure. All nodes are defined in <code>src/col/vct/col/ast/Node.scala</code>. Other than some primitive types and collection types like <code>Int</code>, <code>String</code>, <code>Seq[_]</code> and tuples <code>(_, _)</code>, all types in the tree are descendants of <code>Node</code>.</p>
<p>Nodes are split into two kinds:</p>
<ul>
<li><strong>Descendants of <code>NodeFamily</code></strong>. These are regular nodes, like expressions and statements.
<ul>
<li>They have structural equality, meaning comparing them constitutes comparing their fields.</li>
<li>It makes sense to say that each family of nodes should rewrite to itself: one <code>Statement</code> should always be rewritten to another <code>Statement</code>.</li>
</ul>
</li>
<li><strong>Descendants of <code>Declaration</code></strong>. These are nodes to which we can refer.
<ul>
<li>They have reference equality, which means a <code>new Variable(TInt) != new Variable(TInt)</code>.</li>
<li>It make sense to ask in which scope the declaration can be referred to. For example, a reference to an argument makes no sense outside the method it is declared in.</li>
<li>We should be able to rewrite a declaration to zero, one or more successors of itself.</li>
</ul>
</li>
</ul>
<p>We will not exhaustively describe all kinds of node here, but we highlight the ones that have special Properties.</p>
<h2 id="expr"><a class="header" href="#expr">Expr</a></h2>
<p>All expressions have a type:</p>
<pre><code class="language-scala">trait ExprImpl[G] { this: Expr[G] =&gt;
	def t: Type[G]
}
</code></pre>
<p>You may presume that the node is <code>check</code>ed before its type is queried, and may crash otherwise. The type of expressions is closely related to coercion.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>The relations between types must be defined in <code>Types.leastCommonSuperType</code> and <code>CoercionUtils.getCoercion</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>The normal way to create references to a declaration in a program is by naming it. This creates a few obligations, for example:</p>
<ul>
<li>Declarations must have a consistent and unique name with regards to its scope</li>
<li>References to a declaration must name an existing declaration</li>
<li>Renaming declaration must consider all its references
(Otherwise, we may silently refer to the wrong declaration)</li>
<li>Moving declarations or references across scopes must consider what declaration we are pointing to
(Otherwise, we may silently refer to the wrong declaration)</li>
<li>Importing internal definitions and generating side conditions must generate fresh unique names
(Otherwise, we may silently refer to the wrong declaration)</li>
</ul>
<p>We had this approach in earlier versions of VerCors, leading to declarations with a lot of underscores, and <code>VERCORS</code>/<code>SYSTEM</code>/<code>INTERNAL</code> prefixes. Even still this would probably be pretty manageable as long as the number of rewriters is not too big. As of writing we have 67 different rewriting steps, so this is no longer the case.</p>
<h2 id="no-names"><a class="header" href="#no-names">No names!</a></h2>
<p>We have instead elected to get rid of names entirely, replacing them with explicit references instead. This is a lie, because the initial input to VerCors of course <em>does</em> contain names, but it is a convenient lie: in all other passes the names are not relevant to rewriters. For debug output the preferred name for declarations is stored nevertheless in the <code>preferredName</code> of the origin of the declaration.</p>
<h2 id="tying-the-knot"><a class="header" href="#tying-the-knot">Tying the knot</a></h2>
<p>For simple declaration types like variables, we need to do nothing special to rewrite them. We can think of the following order to rewrite them:</p>
<ul>
<li>Rewrite all the variables of a <code>Scope</code></li>
<li>Rewrite the body of the <code>Scope</code>, which may or may not contain references to the variables.</li>
</ul>
<p>We can then account which <code>Pre</code>-variable is rewritten to which <code>Post</code>-variable, and substitute references accordingly. Note that the variables of the <code>Scope</code> may themselves contain references to variables (e.g. type variables), but we can argue that by the structure of the scopes they have already been rewritten.</p>
<p>This convenient structure manifestly does not work for e.g. method invocations. Consider this simple program:</p>
<pre><code>void p() {
	q();
}

void q() {
	p();
}
</code></pre>
<p>There is no way to order the rewrites correctly here:</p>
<ol>
<li>We cannot name the succesor of <code>p</code> before rewriting <code>p</code></li>
<li>We cannot rewrite the body of <code>p</code> before knowing the successor of <code>q</code></li>
<li>We cannot name the succesor of <code>q</code> before rewriting <code>q</code></li>
<li>We cannot rewrite the body of <code>q</code> before knowing the successor of <code>p</code></li>
<li><code>goto 1</code></li>
</ol>
<p>The way we resolve this by making references lazy in general. We can still refer directly to declaration that we know of in context, such as temporary variables, by wrapping them in <code>DirectRef</code>. If not, we supply the computation that will resolve the reference to <code>LazyRef</code>. Importantly, this computation need not be valid immediately, it must be correct only after the <code>Rewriter</code>.</p>
<p>By default, we store one-to-one succesors in a map. References then by default construct a <code>LazyRef</code> that looks up the successor in this map. The actual mechanics of this are explained further in <a href="resolution.html">Resolution</a> and <a href="rewriting-succession.html">Succession</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="origins"><a class="header" href="#origins">Origins</a></h1>
<p>The origin is a mandatory field in every node, and is the facility by which we store any and all metadata about the node. It arranges the preferred naming scheme of nodes that should have a name, it describes the context in which the node was created, and can remember what text range(s) in the input participated in making the node.</p>
<p>As it is metadata that is nominally not semantically relevant, it does not participate in the structural equality of nodes.</p>
<h1 id="naming"><a class="header" href="#naming">Naming</a></h1>
<p>The name of a node is not relevant to rewriting logic, so it is included in the metadata. For simple source input, the preferred name is just the same as it is in the source. For generated nodes we can use <code>PreferredName</code> and <code>NamePrefix</code> to indicate the preferred name, or its shorthand <code>Origin.where(name = ..., prefix = ...)</code>. We emphasize once more that the name has no semantic relevance: VerCors would be equally sound if all preferred names are <code>x</code>.</p>
<p>The preferred name is currently used in two places:</p>
<ul>
<li><code>vct.col.print.Namer</code> for debug output and some source transformation outputs (e.g. VeyMont);</li>
<li><code>viper.api.transform.ColToSilver</code> for serialization into the Viper language.</li>
</ul>
<h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>For debugging purposes we can add context to an origin. This is typically not necessary for reporting verification failures, as they are reported very close to the input origin. Nevertheless it is useful to know why a node exists, so we mostly add ad-hoc instances of <code>LabelContext</code>, or its shorthand <code>Origin.where(context = ...)</code>.</p>
<h1 id="source-context"><a class="header" href="#source-context">Source Context</a></h1>
<p>Most origins contain at least one pair of <code>ReadableOrigin</code> and <code>PositionRange</code>. Often it is tempting to "just ask" what file position a node comes from, but it is not very often so straightforward to explain away the reason a node exists as such. Nevertheless it is useful to know what source code primarily contributed to the node.</p>
<p><code>Origin</code> extends <code>HasContext</code>, which defines <code>messageInContext</code> to render a message in the context it describes. This will usually contain the file name, as well as the fragment in the file that the origin refers to. There is also <code>Origin.shortPosition</code>, which will attempt to locate an arbitrary file position in the <code>Origin</code> - this is generally not advisable to use outside debugging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checking"><a class="header" href="#checking">Checking</a></h1>
<p>In general we attempt to design the AST in such a way that it is not possible to represent invalid situations. When that is not possible, we implement structural checks on the AST when it is convenient.</p>
<h1 id="the-ambiguous-pattern"><a class="header" href="#the-ambiguous-pattern">The <code>Ambiguous</code> pattern</a></h1>
<p>To avoid duplicating code we implement a rigid structure first in a lot of cases, that does not yet connect to the frontends. An example of this is <code>Location</code>, which has rigid alternatives per type of heap location. Since <code>Perm(x.f, _)</code> simply contains an expression <code>x.f</code> rather than something that is immediately identifiable as a location, we punch a hole in <code>Location</code> named <code>AmbiguousLocation</code> that can contain that expression for so long as it is not yet resolved. We then implement a rewriter that scans for the allowed forms of expression in <code>AmbiguousLocation</code> and translates them to a proper location. If the form is not proper, we can simply throw a <code>UserError</code> in the rewriter.</p>
<p>The alternative is that we implement <code>check</code> for <code>AmbiguousLocation</code> and ensure that it contains a correct location. It is not that clear when a location is valid. For example, a <code>JavaDeref</code> can be resolved to a built-in like <code>seqn.size</code>. That does not resolve to a correct location, but it is more convenient to wait until the <code>JavaDeref</code> becomes a <code>Size</code>, rather than needing to be aware of every possible resolution of <code>JavaDeref</code> in <code>AmbiguousLocation</code>.</p>
<h1 id="type-checks"><a class="header" href="#type-checks">Type checks</a></h1>
<p>One dimension along which we cannot escape checking is that of type constraints. Every node that <strong>contains</strong> an expression defines whether it imposes a type constraint on it in <code>CoercingRewriter</code>. This coercion is computed in the implementation of <code>check</code> for every node.</p>
<h1 id="structural-checks"><a class="header" href="#structural-checks">Structural checks</a></h1>
<p>As said before the amount of structural checks implemented in VerCors currently is very limited. Nevertheless we are still missing some important ones at time of writing, so we should look into this more.</p>
<p>The ones that do exist are implemented by extending <code>CheckError</code>, and then overriding <code>check</code> in the Impl-trait of the node you want to implement a check for. Note that it is typically wanted behaviour that the <code>super</code>-implementation of <code>check</code> is included in the result.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coercion"><a class="header" href="#coercion">Coercion</a></h1>
<p>Various nodes contain expressions, such as other expressions (e.g. <code>Plus</code> contains its two arguments) and non-expressions (e.g. <code>Branch</code> contains the conditions for its branches). Each expression position in the tree may induce a typing constraint on the expression in it. For example, the conditions in <code>Branch</code> have to be booleans:</p>
<pre><code class="language-scala">case Branch(branches) =&gt; 
	Branch(branches.map { case (cond, effect) =&gt; (bool(cond), effect) })
</code></pre>
<p>and the arguments of <code>Plus</code> may be integers or rationals:</p>
<pre><code class="language-scala">case Plus(left, right) =&gt;
	firstOk(e, s"Expected both operands to be numeric, but got ${left.t} and ${right.t}.",
		Plus(int(left), int(right)),
		Plus(rat(left), rat(right)),
	)
</code></pre>
<p>Here we coerce each <code>cond : Expr[G]</code> into a boolean, and do nothing with <code>effect</code>. For <code>Plus</code> we pick the first of two transformations that succeeds: either both <code>left</code> and <code>right</code> can be coerced with <code>int</code>, or both can be coerced with <code>rat</code>.</p>
<p>Coercions serve two purposes: they check that the AST is well-typed, and can be used in <code>Rewriter</code>s to enact transformations on the AST.</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type checking</a></h2>
<p>The coercions in <code>CoercingRewriter</code> are run for every node during a <code>check</code> in the implementation of <code>DeclarationImpl</code> and <code>NodeFamilyImpl</code> (which together span all nodes). They use a special descendant of <code>CoercingRewriter</code> called <code>NopCoercingRewriter</code> that applies no transformtions along coercions.</p>
<p>All nodes that contain expressions should have their coercions defined in <code>CoercingRewriter</code>. If the expression should be in a simple type (class), you can use <code>coerce(expression : Expr[Pre], type : Type[Pre])</code>. Shorthands for several common types are defined, such as <code>rat</code>, <code>bool</code> and <code>int</code>.</p>
<p>If your node can be interpreted in multiple ways, determined by the type of its arguments, you can use the <code>firstOk</code> helper to select the first set of coercions that suceed on the arguments. Only if all alternatives fail an error is raised.</p>
<h2 id="transformations"><a class="header" href="#transformations">Transformations</a></h2>
<p>It is occasionally useful to implement transformation along the description of a coercion. Coercions are described by the node family <code>Coercion</code>. For example, coercing a <code>seq&lt;int&gt;</code> into a <code>seq&lt;rational&gt;</code> is described by <code>CoerceMapSeq(CoerceIntRat(), TInt(), TRational())</code>. Rewriters that extend <code>CoercingRewriter</code> have access to this coercion object by overriding <code>applyCoercion</code>.</p>
<p>One example of this behaviour is in the overloaded interpretation of <code>null</code>. In VerCors the array types are entirely separate from the class types. Thus, <code>null</code> can be coerced into either an array or a class type. In the rewriter that encodes arrays, <code>ImportArray</code>, we filter for usages of <code>null</code> for arrays by translating a <code>CoerceNullArray</code> coercion to the appropriate value for a null array.</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>Note that very nearly all defined/permissible coercions are promoting coercions. That is, they only admit coercions when a value definitely fits into the target type of the coercion. This is defined programatically by defining <code>isPromoting</code> in <code>CoercionImpl</code>. Currently the only exception is rationals into <code>zfrac</code> into <code>frac</code>. We have not investigated yet whether it is a good idea to define more implicit coercions to represent situations like demoting a <code>uint64</code> into a <code>uint32</code> - perhaps they are better suited as explicit non-<code>ApplyCoercion</code> nodes at an early point. Failures in coercion are reported to the blame in <code>Program</code>, mostly because we have no other good place to put it.</p>
<p>The other safety concern related to promoting coercions is that sets only map over promoting coercions due to the fact that the default coercion is defined as \(x \in \textsf{input} \leftrightarrow \textsf{coerce}(x) \in \textsf{output}\). Alternative encodings we investigated are cumbersome because they add additional necessary proof steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretty-printing"><a class="header" href="#pretty-printing">Pretty-Printing</a></h1>
<p>The pretty printer of VerCors is derived from "A prettier printer" by Philip Wadler, accessible <a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">here</a>. Typesetting a COL AST is done in three stages: it is first translated into a document tree, then a list of elements, then text.</p>
<h1 id="col"><a class="header" href="#col">COL</a></h1>
<p>Each node implements <code>layout</code>, which is externally accessible via <code>show</code>. The only purpose of <code>show</code> is to wrap the document tree with <code>NodeDoc</code>, so that we may later recall what document tree corresponds to what COL tree. If you forget to implement <code>layout</code> a debugging representation of the node is printed that does not look entirely terrible.</p>
<p><code>Expr</code> is a bit more special: it demands an implementation of <code>def precedence: Int</code> for each expression. You can use <code>bind</code>, <code>assoc</code>, <code>nassoc</code>, <code>lassoc</code> and <code>rassoc</code> as conveniences to see whether sub-expressions require parentheses:</p>
<ul>
<li><code>bind</code> adds parentheses if the precedence of the subexpression is lower than the specified precedence</li>
<li><code>assoc</code> adds parentheses if the precedence of the subexpression is strictly lower than our precedence (i.e. we "associate" with the subexpression)</li>
<li><code>nassoc</code> adds parentheses if the precedence of the subexpression is less or equal than our precedence (i.e. we do not "associate" with the subexpression)</li>
<li><code>lassoc</code> is the correct implementation for a left-associative binary operator (e.g. <code>+</code>, <code>*</code>)</li>
<li><code>rassoc</code> is the correct implementation for a right-associative binary operator (e.g. <code>::</code>, <code>==&gt;</code>)</li>
</ul>
<h1 id="document-tree"><a class="header" href="#document-tree">Document tree</a></h1>
<p>The elements of a document tree are as follows:</p>
<ul>
<li><code>Empty</code>, which renders as nothing</li>
<li><code>Text(String)</code>, which simply represents a piece of text. Must not contain newlines.</li>
<li><code>Cons(Doc, Doc)</code> (or <code>Doc &lt;&gt; Doc</code>), which represents the unspaced concatenation of two trees.</li>
<li><code>Nest(Doc)</code>, which indicates the tree should be nested (i.e. indented)</li>
<li><code>Group(Doc)</code>, which indicates that newlines should preferrably be removed from the tree.</li>
<li><code>Line</code> and <code>NonWsLine</code>, which are both newlines. If collapsed in a <code>Group</code>, only <code>Line</code> is replaced with one space.</li>
<li><code>NodeDoc(Node[_], Doc)</code>, which has no effect on typesetting, but indicates this document tree corresponds to this node.</li>
</ul>
<p>The deviations from Wadler's algorithm are:</p>
<ul>
<li>We have no <code>&lt;|&gt;</code> to indicate alternatives. Instead our very opinionated <code>Group</code> has in effect two alternatives: we prefer for it to be printed on one line, but it may keep the <code>Line</code>s and <code>NonWsLine</code>s if necessary to reduce its horizontal occupancy. When <code>Group</code> is nested we first peel off the outer <code>Group</code>, keeping the inner <code>Group</code> if possible.</li>
<li>The <code>flatten</code> of <code>NonWsLine</code> is <code>Empty</code> instead of <code>Text(" ")</code></li>
<li><code>NodeDoc</code> is there for post-processing</li>
</ul>
<p>Otherwise the typesetting algorithm is a straightforward transliteration of the paper.</p>
<p><code>Doc</code> has several convenient operators to make trees:</p>
<ul>
<li>On the right hand side of operators, you can write anything that implements <code>Show</code>, such as <code>Node[_]</code></li>
<li><code>x &lt;&gt; y</code> is <code>Cons(x, y)</code></li>
<li><code>x &lt;+&gt; y</code> is <code>x &lt;&gt; " " &lt;&gt; y</code></li>
<li><code>x &lt;/&gt; y</code> is <code>x &lt;&gt; NonWsLine &lt;&gt; y</code></li>
<li><code>x &lt;+/&gt; y</code> is <code>x &lt;&gt; Line &lt;&gt; y</code></li>
<li><code>x &lt;&gt;&gt; y</code> is <code>x &lt;&gt; Nest(Line &lt;&gt; y)</code></li>
<li><code>Doc.fold</code> applies a function on pairs of <code>Doc</code> until there is only one <code>Doc</code>. If the sequence of <code>Doc</code>s is empty, the result is <code>Empty</code>.</li>
<li><code>Doc.spread</code>, <code>Doc.lspread</code> and <code>Doc.rspread</code> place spaces between <code>Doc</code>s. <code>r</code> has an extra space on the right, <code>l</code> has an extra space on the left.</li>
<li><code>Doc.stack</code> places newlines between <code>Doc</code>s that reduce to a space in a <code>Group</code>.</li>
<li><code>Doc.arg</code> indents a <code>Doc</code> on a new line, then appends another newline. Both newlines reduce to nothing in a <code>Group</code>. Appropriate for an argument to a function or control structure like <code>while</code>, when wrapped in a <code>Group</code>.</li>
<li><code>Doc.args</code> combines comma-separated arguments with newlines that reduce to a space.</li>
<li><code>Doc.spec</code> and <code>Doc.inlineSpec</code> surround the <code>Doc</code> with <code>/*@ @*/</code> if necessary. Note: the context only indicates to the tree argument that we are now in a spec if the argument to <code>Doc.spec</code> is not yet a <code>Doc</code>, but something yet to be showed. This can be delayed with <code>Show.lazily</code> if necessary.</li>
</ul>
<h1 id="elements"><a class="header" href="#elements">Elements</a></h1>
<p>After typesetting the document we are left with a list of elements, which are one of two variants:</p>
<ul>
<li><code>ELine(indent: Int)</code>, which renders a new line with a given amount of indentation. The context contains an indentation string, that is repeated <code>indent</code> amount of times</li>
<li><code>EText(text: String)</code>, which is rendered as its constitutent text.</li>
</ul>
<p>Additionally, we again remember what corresponds to which node, for post-processing:</p>
<ul>
<li><code>EStart(Node[_])</code> indicates the start of a region that represents that node.</li>
<li><code>EEnd(Node[_])</code> indicates the end of that region.</li>
</ul>
<p>The metadata is used in <code>Doc.highlight</code>, which can point to a node in a rendered tree.</p>
<p>Any node that implements <code>Show</code> has convenience functions <code>write(Appendable)</code> and <code>toStringWithContext(Ctx)</code> to convert the <code>Show</code> to text.</p>
<h1 id="context-1"><a class="header" href="#context-1">Context</a></h1>
<p>The class <code>vct.col.print.Ctx</code> is available when rendering nodes and can be updated when the parent context is relevant (such as being inside a specification). Otherwise it contains information like declaration names, the horizontal width, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparing"><a class="header" href="#comparing">Comparing</a></h1>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>All nodes already implement <code>==</code>, which corresponds to the property that the nodes are semantically equivalent. This means that the following properties of nodes are considered when checking them for equality:</p>
<ul>
<li>Descendants of <code>NodeFamily</code> are deemed equal by structural equality: they must be of the same type, and have the same fields recursively.</li>
<li>Descendants of <code>Declaration</code> are deemed equal by referential equality: two separate instances of structurally equal <code>Declaration</code>s are <em>not</em> equal.</li>
<li>The <code>blame</code> of nodes is <em>not</em> considered in equality: this is an unfortunate design mistake. Blames should be redesigned so that they are a structural component of the AST.</li>
<li>The origin of nodes is not considered in equality: this is correct, because the origin only contains metadata not relevant for the boolean verification result of the node.</li>
</ul>
<p>If this notion of equality does not fit, you can instead use <code>compare</code>.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Each node implements <code>compare</code> through code generation. Its only argument is the node to compare to, and it returns a lazy list of <code>CompareResult</code>. The idea is that <code>compare</code> recurses into the left and right argument simultaneously, reporting any differences along the way. The three alternatives for <code>CompareResult</code> are:</p>
<ul>
<li><code>StructuralDifference</code>: in this subtree the kinds of node are different, or they have a different structure at that level. For example: a node that contains a <code>Seq</code> has a differing number of arguments.</li>
<li><code>MatchingReference</code>: so far the tree is structurally equal, and we have recursed to a point that left and right are a reference to a declaration. The references may or may not be equal.</li>
<li><code>MatchingDeclaration</code>: these declarations are structurally equivalent, but they may or may not be reference-equal.</li>
</ul>
<p>From here several useful abstractions are implemented:</p>
<ul>
<li><code>Compare.compare</code>: the same as <code>compare</code> above, but attempt to reconcile structural differences by bringing left and right into a specified normal form. This is useful to compare nodes e.g. under equivalence of associativity of <code>**</code>.</li>
<li><code>Compare.getIsomorphism</code>: attempts to match up <code>MatchingReference</code> and <code>MatchingDeclaration</code> that point to the same declarations. If this succeeds, we say that left and right are isomorphic by substituting left declaration for right declarations. In that case the result is <code>Right</code>: a map of left-declaration to right-declaration. If not, a list of differences is returned: either structural differences or declarations that cannot be reconciled.</li>
<li><code>ApplyTermRewriter</code>: uses <code>compare</code> to implement rewriting rules, by explicitly accepting a <code>StructuralDifference</code> in the case that the left term is a <code>Local</code> used in the rule pattern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization"><a class="header" href="#serialization">Serialization</a></h1>
<p>A lightly used feature of COL is serialization and deserialization: the ability to store a COL tree as an array of bytes, and the ability to translate the bytes back into a COL tree.</p>
<h2 id="serialization-on-the-vercors-side"><a class="header" href="#serialization-on-the-vercors-side">Serialization on the VerCors side</a></h2>
<p>Each node defines two serialization methods:</p>
<pre><code>def serialize(decls: Map[Declaration[G], Long]): vct.col.ast.serialize.&lt;Node&gt;

def serializeFamily(decls: Map[Declaration[G], Long]): vct.col.ast.serialize.&lt;NodeFamily&gt;
</code></pre>
<p>The <code>decls</code> parameter is used to store the representation of references in the AST. There is also a utility method <code>vct.col.ast.Serialize.serialize</code> that computes a standard assignment of declaration to <code>Long</code> for a <code>Program</code>.</p>
<p>For deserialization objects are generated for each node in <code>vct.col.ast.ops.deserialize</code>, but again the <code>vct.col.ast.Deserialize.deserialize</code> method is there for conveniently deserializing <code>Program</code> nodes.</p>
<h3 id="usage-of-serialization"><a class="header" href="#usage-of-serialization">Usage of serialization</a></h3>
<p>Currently the only usage of serialization internal to VerCors is to cache library files and user inputs. Library files are cached by default, which saves us from having to continually parse them on each run of VerCors. User inputs are currently only cached when a development flag is enabled.</p>
<h2 id="serialization-outside-vercors"><a class="header" href="#serialization-outside-vercors">Serialization outside VerCors</a></h2>
<p>(De)serialization takes an extra step between COL trees and bytes through Protobuf. For those familiar with protobuf, we break with two important standards that are common for protobuf definitions:</p>
<ul>
<li>We do not promise backward or forward compatiblility: we are still in a stage where we extensively experiment with node representation, so we are careful that communication of serialized programs only occurs between identical versions of the serialization format. We may want to have some form of backward compatibility in the future.</li>
<li>The protobuf definition is not the source of truth. Instead we derive a protobuf definition from <code>Node.scala</code>. It may be sensible to explicitly maintain a version of the protobuf definition in tandem with switching to a notion of backwards compatible nodes.</li>
</ul>
<p>On to the good parts: for any VerCors version you can find its protobuf definitions at <code>out/vercors/col/helpers/global/generate.dest/vct/col/ast/col.proto</code>. You can use this file to generate bindings for all common programming languages. This effectively makes it so that any programming language can be used to generate an input to VerCors, e.g. by extending a compiler in whatever language that is written.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolution"><a class="header" href="#resolution">Resolution</a></h1>
<p>Resolution is the process of assigning a meaning to a text name. Resolution occurs in two stages:</p>
<ul>
<li><code>vct.col.resolve.ResolveTypes</code>: Resolves the meaning of types, and loads any library types that are mentioned but not in the input. Declaration with a type can be important in resoving other references, such as field dereferences.</li>
<li><code>vct.col.resolve.ResolveReferences</code>: Resolves everything else.</li>
</ul>
<p>Both resolution stages have the same structure. At each node we receive a context that decides how we resolve that particular node. Before resolving any node, we fist resolve all of its children. This is because the type and well-formdness of children is more often relevant to the parent, than the well-formdness of the parent is to the children. The context is expanded upon by a node before passing it to its children. The recipe is thus as such:</p>
<ol>
<li><code>enterContext</code> decides how to expand the context from a node</li>
<li><code>resolve</code> recureses into the node's children with the updated context</li>
<li><code>resolveOne</code> is called for the node, which may assume the children are well-formed.</li>
</ol>
<p><code>ResolveTypes</code> is followed by its companion rewriter <code>LangTypesToCol</code>, which sets the resolved references in mutable state in stone. Dually the <code>ResolveReferences</code> resolver is followed by <code>LangSpecificToCol</code>.</p>
<h2 id="from-parse-tree-to-col-tree"><a class="header" href="#from-parse-tree-to-col-tree">From parse tree to COL tree</a></h2>
<p>VerCors has two ways of representing a text name:</p>
<ul>
<li>A node contains a <code>Ref</code> that is of type <code>UnresolvedRef</code>. This is appropriate for places where the name is exactly one label (as opposed to a fully qualified name like <code>java.lang.String</code>), and will clearly resolve to a category of declaration. This is unfortunately quite often not the case.</li>
<li>A node remembers the text name temporarily, and contains mutable state to receive the result of resolution. An example of this is <code>JavaLocal</code>.</li>
</ul>
<p>This is an area of VerCors that should be refactored: there should be one clear way to represent an unresolved name.</p>
<h2 id="unresolvedref"><a class="header" href="#unresolvedref"><code>UnresolvedRef</code></a></h2>
<p>This class contains mutable state in its field <code>resolvedDecl</code>, which can be filled by calling <code>UnresolvedRef.resolve</code>. Most occurences of <code>Ref</code> have an entry in <code>ResolveReferences</code>, but it is not clear that there is always a sensible way to implement this.</p>
<h2 id="referrable"><a class="header" href="#referrable"><code>Referrable</code></a></h2>
<p>Any other situation should just remember the text name from the input in a node, and contain mutable state that receives the result of resolving it. By convention, this is a <code>var ref: Option[?] = None</code>. Other code like <code>check</code> and <code>t</code> may assume the <code>ref</code> is filled.</p>
<p>Usually the resolution result points to something in the AST, in which case you should use <code>Referrable</code>. It can point to the following kinds of thing:</p>
<ul>
<li>Exactly one <code>Declaration</code>;</li>
<li>A portion of a declaration, such as field #2 in the multi-declaration <code>int x, y, z;</code>;</li>
<li>A reference to an intrinsic part of the language that cannot be directly parsed, such as cuda's <code>blockDim</code>;</li>
<li>A reference to a VerCors-built-in concept, like the <code>.size</code> of a sequence;</li>
<li>A reference to a construct that exists implicitly, such as Java's default constructor.</li>
</ul>
<p>It is a bit frustrating that all declarations are essentially duplicated under <code>Referrable</code>, but it does give us the flexibility to make names point to whatever we want.</p>
<h2 id="from-col-tree-to-resolved-tree"><a class="header" href="#from-col-tree-to-resolved-tree">From COL tree to resolved tree</a></h2>
<p>When using an <code>UnresolvedRef</code> or adding a <code>Option[Referrable]</code> variable, we should take care that an appropriate entry is added in <code>Resolve{References,Types}.resolveOne</code>. We split out the resolution by language (including the specification language), which usually derives an appropriate <code>Referrable</code> from the <code>{Type,Reference}ResolutionContext</code>. Note again that we are allowed to e.g. query the type of child nodes, which is very relevant in resolving e.g. instance methods.</p>
<h2 id="from-resolved-tree-to-ref"><a class="header" href="#from-resolved-tree-to-ref">From resolved tree to <code>Ref</code></a></h2>
<p>The companion rewriters <code>LangTypesToCol</code> and <code>LangSpecificToCol</code> translate resolved references into a <code>Ref</code> (that is not an <code>UnresolvedRef</code>). From then on references are defined only by pointing at the declaration it resolved. A consequence of this is that past the language-specific pass pointing to anything other than exactly one declaration as above is not possible.</p>
<p>Note: the <code>LangSpecificToCol</code> pass has accumulated far too much logic. The ideal path to implement a feature in VerCors is that you design new concepts in the core of COL that you need, and figure out a straightforward way to map to it in <code>LangSpecificToCol</code>. The task of <code>LangSpecificToCol</code> is not to lower language features into low-level concepts immediately, and VerCors often benefits from well-designed features in the core of COL across front-ends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewriting"><a class="header" href="#rewriting">Rewriting</a></h1>
<p>The main activity of VerCors is rewriting a program. We use the concept of a <code>Rewriter</code> to structure the transformation of a program tree in an understandable and disciplined manner.</p>
<p>A rewriter recurses into one tree, and calls <a href="./rw-dispatch.html">dispatch</a> for each element of the tree by default. To ensure that each part of the tree is actually rewritten, we use the concept of <a href="./rw-generation.html">generations</a> to make the prior tree and the new tree have unrelated types. Declarations are a bit special: each declaration need not be <a href="./rw-succession.html">succeeded</a> by exactly one declaration of the same kind â€” as opposed to structural nodes. By transforming a program tree the verification failures that may occur in the program change, so we explain how to transform the errors to be about the input by providing <a href="./rw-blame.html">blames</a>.</p>
<p>The later sections describe concepts that are more advanced, and require careful consideration to whether they are appropriate. <a href="./rw-nested.html">Nested rewriters</a> can be used when the rewriting behaviour materially changes when recursing into a certain node. It can be confusing to read, because you might intuit that the patterns in the parent rewriter are still used, when they are not. <a href="./rw-substitution.html">Substitution</a> can be helpful if your rewriting process is effectively two-step, but it is more straightforward to glue on a simple behavior to one rewriter. Nevertheless it is often actually better to consider explicitly how you might model the substitution statefully anyway: this gives a clearer picture what should happen when e.g. nodes needing subtitution are nested.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outline"><a class="header" href="#outline">Outline</a></h1>
<p>When implementing a new rewriter you should make a class that extends <code>Rewriter</code>. Additionally it should have a companion object that extends <code>RewriterBuilder</code>: other than giving a <code>key</code> and <code>desc</code> to present to the user, it describes how to construct a rewriter with <code>apply</code>. The <code>apply</code> method is defined implicitly if you make your rewriter a <code>case class</code>.</p>
<p>The outline of an empty rewriter then looks like this:</p>
<pre><code class="language-scala">package vct.col.rewrite

import vct.col.ast._
import vct.col.rewrite.{Generation, Rewriter, RewriterBuilder}
import vct.col.util.AstBuildHelpers._

case object MyRewriter extends RewriterBuilder {
  override def key: String = "my"
  override def desc: String = "Apply a transformation to the COL tree"
}

case class MyRewriter[Pre &lt;: Generation]() extends Rewriter[Pre] {
  
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatch"><a class="header" href="#dispatch">Dispatch</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
